[{"title":"技术报告-xiaodangao","path":"/2024/04/22/实验报告/","content":"利用 Git、Hexo 和 Stellar 主题创建 GitHub Pages 的技术报告 介绍 本技术报告旨在介绍如何利用 Git、Hexo 和 Stellar 主题来创建个人博客的 GitHub Pages 网站。GitHub Pages 是一个由 GitHub 提供的静态网站托管服务，而 Git 是一个分布式版本控制系统，Hexo 是一个快速、简洁且高效的博客框架，Stellar 主题则是 Hexo 的一个流行主题之一。 步骤 1. 安装 Git、Node.js 和 Hexo 首先，确保你的系统中安装了 Git 和 Node.js。然后，使用 npm（Node.js 包管理器）安装 Hexo： npm install -g hexo-cli 2. 创建 Hexo 项目 在命令行中执行以下命令来创建一个新的 Hexo 项目： hexo init my-blog cd my-blog npm install 3. 配置 Hexo 编辑 Hexo 项目的配置文件 _config.yml，设置博客的基本信息和主题等配置。 4. 安装 Stellar 主题 在 Hexo 项目中安装 Stellar 主题： git clone https://github.com/lqzhgood/hexo-theme-stellar themes/stellar 5. 配置 Stellar 主题 编辑 Hexo 项目的配置文件 _config.yml，设置主题为 Stellar 主题，并进行其他主题相关的配置。 6. 创建和发布内容 使用 Hexo 创建新的文章或页面，并使用 Git 将更改推送到 GitHub。 7. 部署到 GitHub Pages 在 GitHub 上创建一个新的仓库，将 Hexo 项目的内容推送到该仓库，并启用 GitHub Pages 服务。 结论 通过以上步骤，我们成功地利用 Git、Hexo 和 Stellar 主题创建了个人博客的 GitHub Pages 网站。这样，我们就可以方便地使用 Markdown 编写博文，通过 Git 进行版本控制，并使用 Hexo 和 Stellar 主题创建漂亮的博客页面。","tags":["博客搭建"],"categories":["博客搭建"]},{"title":"Hello World","path":"/2024/04/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment"},{"title":"关于Dataframe数据保存出现的问题xiaodangao","path":"/2023/11/13/关于Dataframe数据保存出现的问题-xiaodangao/","content":"问题描述： 读入csv文件，执行以下程序 import pandas as pd import numpy as np # pd.set_option(&#x27;max_colwidth&#x27;,2000) sub_file_name=&quot;submission.csv&quot; df = pd.read_csv(sub_file_name,header=None) pro_file_name=&quot;problem.csv&quot; df2 = pd.read_csv(pro_file_name,header=None) pid=test[2].to_string(index=False) res=df2[df2[0] == pid] print(len(res[3].to_string(index=False))) 无论res[3]长度有多长，结果均显示len为50，也就是说将它保存为字符串格式也会发生错误，也就是“…”省略号将被保存。 这是因为maxcolwidthmax_colwidthmaxc​olwidth被设置为50。 解决办法： import pandas as pd import numpy as np pd.set_option(&#x27;max_colwidth&#x27;,2000)#设置最大长度为2000 sub_file_name=&quot;submission.csv&quot; df = pd.read_csv(sub_file_name,header=None) pro_file_name=&quot;problem.csv&quot; df2 = pd.read_csv(pro_file_name,header=None) pid=test[2].to_string(index=False) res=df2[df2[0] == pid] print(len(res[3].to_string(index=False))) 如程序所示，将最大长度设置为2000。（如果字符串更长可以设置更长的参数）","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"交叉验证集相关xiaodangao","path":"/2023/03/14/交叉验证集相关-xiaodangao/","content":"交叉验证相关 过拟合、欠拟合问题 ​\t如图所示，在进行多项式次数选择时会发生相关问题。如果用一个较低次的多项式来拟合，那么就会造成损失函数JJJ过大，会产生高偏差(high bias)问题。如果用一个高的多项式来拟合，那么就会造成损失函数JJJ过小的问题，会产生高方差(high variance)问题。这意味着你虽然当前数据拟合的非常成功，但如果将模型去用于预测别的数据，那么会导致有较大出入。 ​\t我们利用正则化来解决过拟合问题（正则化见后面文章）：改写代价函数JJJ J(θ)=12m[∑i=1m(hθ(xi−yi)2)+λ∑j=1nθj2]J(\\theta) = \\frac{1}{2m}[\\sum_{i=1}^m(h_{\\theta}(x^{i} - y^i)^2)+\\lambda\\sum_{j=1}^n\\theta_j^2] J(θ)=2m1​[i=1∑m​(hθ​(xi−yi)2)+λj=1∑n​θj2​] ​\t我们将数据集分为训练集和测试集现在已经不足以很好的解决这个问题了 ​\t如上图所示，这并不是一种好办法。我们去通过增加ddd即多项式次数来得到相应参数，利用该参数去计算JtestJ_{test}Jtest​（测试集代价函数），当然你一定有一个次数，它会使你的JtestJ_{test}Jtest​最小，但是这样的话就会降低你模型的泛化能力。那么这样，引入测试集的意义就不存在了。举一个例子，好像是你学习为了取得好的成绩，但是你偷看了考试答案，这当然会使得你的本场考试成绩提升，但是并不代表你模型本身取得较好的学习能力。 ​\t这就引入了交叉验证集（cross validation set）。我们通过交叉验证集中的代价函数来验证模型是否拟合程度 ​\t注意这里的代价函数均不含正则化项的。之前那个图中找到最小的JtestJ_{test}Jtest​就变成了找到最小的JcvJ_{cv}Jcv​来选择一个比较符合的多项式次数。 ​\t而测试集的代价函数则被用来展示泛化误差估计这个模型在新数据上的表现。 ​\t最后还有几个问题 ​\t关于交叉验证集和验证集：交叉验证集是因为训练集太小，无法直接分出训练集和验证集，采用交叉验证的方式如下图所示： ​\t首先将数据集随机分为测试集和训练集，并且将训练集分为五份[S折交叉验证（ S-Folder Cross Validation）]。每次都用其中4份来训练模型，粉红色的那份用来验证4份训练出来的模型的准确率，记下准确率。然后在这5份中取另外4份做训练集，1份做验证集，再次得到一个模型的准确率。直到所有5份都做过1次验证集，也即验证集名额循环了一圈，交叉验证的过程就结束。算得这5次准确率的均值。留下准确率最高的模型，即该模型的超参数是什么样的最终模型的超参数就是这个样的。 ​\t训练集主要是为了确定参数，而验证集是为了确定超参数。所谓参数就是模型可以根据数据可以自动学习出的变量，应该就是参数。比如，深度学习的权重，偏差等（非人为给定）超参数：就是用来确定模型的一些参数，超参数不同，模型是不同的(比如说：假设都是CNN模型，如果层数不同，模型不一样，虽然都是CNN模型。)，超参数一般就是根据经验确定的变量。在深度学习中，超参数有：学习速率，迭代次数，层数，每层神经元的个数等等。","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"[machinelearning学习笔记]逻辑回归xiaodangao","path":"/2023/03/09/[machine-learning学习笔记]逻辑回归-xiaodangao/","content":"逻辑回归 目的：分类 一、Sigmoid函数 ​ 公式如下： g(z)=11+e−zg(z) = \\frac {1}{1+e^{-z}} g(z)=1+e−z1​ ​\t图中SigmoidSigmoidSigmoid函数将任意输入映射到[0,1][0,1][0,1]区间，我们通过线性回归的到预测值，再将该值映射到SigmoidSigmoidSigmoid函数中，这样就完成了值到概率的转换。变成了分类任务。 ​\t利用SigmoidSigmoidSigmoid函数得出的预测函数： hθ=g(θTx)=11+e−θxh_{\\theta} = g(\\theta^Tx) = \\frac{1}{1+e^{-\\theta x}} hθ​=g(θTx)=1+e−θx1​ ​\t其中 θ0+θ1x1+,...,+θnxn=∑i=1nθixi=θTx\\theta_0 + \\theta_1x_1+,...,+\\theta_nx_n = \\sum_{i=1}^{n}\\theta_ix_i = \\theta^Tx θ0​+θ1​x1​+,...,+θn​xn​=i=1∑n​θi​xi​=θTx ​\t这个就和线性回归中的函数很像了。 ​\t由于是二分类，只有TrueTrueTrue、FalseFalseFalse两种结果，因此由上述函数得到的预测分类的概率分别为： P(y=1∣x;θ)=hθ(x)P(y=1|x;\\theta) = h_{\\theta}(x) P(y=1∣x;θ)=hθ​(x) P(y=0∣x;θ)=1−hθ(x)P(y=0|x;\\theta) = 1-h_{\\theta}(x) P(y=0∣x;θ)=1−hθ​(x) ​\t因此 P(y∣x;θ)=(hθ(x))y(1−hθ(x))1−yP(y|x;\\theta) = (h_{\\theta}(x))^y(1-h_{\\theta}(x))^{1-y} P(y∣x;θ)=(hθ​(x))y(1−hθ​(x))1−y ​\t解释：这里只不过是把上面P(y=1)P(y=0)P(y=1)P(y=0)P(y=1)P(y=0)整合了一下。 ​\t利用似然函数来得到损失函数（如果不太清楚直接看损失函数就可以，这里损失函数与线性回归不一样），似然函数如下： L(θ)=∏i=1m(hθ(xi))yi(1−hθ(xi))1−yiL(\\theta) = \\prod_{i=1}^m(h_{\\theta}(x_i))^{y_i}(1-h_{\\theta}(x_i))^{1-y_{i}} L(θ)=i=1∏m​(hθ​(xi​))yi​(1−hθ​(xi​))1−yi​ ​\t将似然函数取对数得损失函数为： l(θ)=logL(θ)=∑i=1m(yiloghθ(xi)+(1−yi)log(1−hθ(x)))l(\\theta) = logL(\\theta) = \\sum_{i=1}^{m}(y_ilogh_{\\theta}(x_i)+(1-y_i)log(1-h_{\\theta}(x))) l(θ)=logL(θ)=i=1∑m​(yi​loghθ​(xi​)+(1−yi​)log(1−hθ​(x))) ​\t我们得到代价函数为（foreachθfor\\quad each \\quad\\thetaforeachθ）: J(θ)=−1m∑i=1m[l(θ)]J(\\theta) = -\\frac{1}{m}\\sum_{i=1}^m[l(\\theta)] J(θ)=−m1​i=1∑m​[l(θ)] ​\t我们的目标为最小化代价函数。 ​\t那么，为什么要这样来构造损失函数呢？ ​\t因为如果按照线性回归的方法来构造损失函数，那么得到的函数并不是凸函数，由于初始化参数不同，很容易走到局部最小值点而非全局最小值点。采用如上方法构造的函数为凸函数，这使得其能更好的利用到梯度下降算法中。（关于推导记住就行） ​ ​\t我们采用梯度下降法时的偏导数如下， ​ ∂∂θjJ(θ)=1m∑i=1m(hθ(xi)−yi)xij\\frac {\\partial}{\\partial_{\\theta_j}}J(\\theta) = \\frac{1}{m}\\sum_{i=1}^m(h_{\\theta}(x_i)-y_i)x_i^j ∂θj​​∂​J(θ)=m1​i=1∑m​(hθ​(xi​)−yi​)xij​ ​\t因此，我们进行同步更新时的柿子：（看起来和线性回归差不多） θj=θj−α∂∂θjJ(θ)\\theta_j = \\theta_j-\\alpha\\frac {\\partial}{\\partial_{\\theta_j}}J(\\theta) θj​=θj​−α∂θj​​∂​J(θ) ​\t总结：逻辑回归是要预测二分类问题，在线性回归的基础上增加了一个sigmoidsigmoidsigmoid外壳，然后改写损失函数，进而将其变为凸函数，从而更好地进行梯度下降操作。","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"[leetcode]2584.分割数组使乘积互质（质因数分解）xiaodangao","path":"/2023/03/08/[leetcode]2584. 分割数组使乘积互质 （质因数分解）-xiaodangao/","content":"题目链接：分割数组使乘积互质 思路：指针循环从[0,len−1)[0,len-1)[0,len−1)每次动态维护指针左边所有数与指针右边所有数质因数交集，第一次交集为0的地方为答案。首先将打表10610^6106之内的质数，这样质因数分解快一些。 Code:Code:Code: class Solution &#123; public: #define ll long long #define pb push_back const int N = 1e6 + 10; int tot; int prime[1000010]; bool st[1000010]; void get_it() &#123; for (int i = 2; i &lt;= 1000000; ++i) &#123; if (st[i]) continue; prime[++tot] = i; if (i &gt;= 10000) continue; for (int j = i * i; j &lt;= 1000000; j += i) &#123; st[j] = true; &#125; &#125; &#125; int cnt[1000010]; vector&lt;int&gt; arr[10100]; void work(int x, int id) &#123; int i = 1; while (prime[i] * prime[i] &lt;= x) &#123; if (x % prime[i] == 0) &#123; while (x % prime[i] == 0) x /= prime[i]; cnt[prime[i]]++; arr[id].pb(prime[i]); &#125; i++; &#125; if (x != 1) &#123; cnt[x]++; arr[id].pb(x); &#125; &#125; int res = 0; int findValidSplit(vector&lt;int&gt;&amp; nums) &#123; get_it(); int id = 0; for (auto i : nums) &#123; work(i, id++); &#125; memset(st, 0, sizeof st); int len = nums.size(); if (len == 1) return -1; for (int i = 0; i &lt; len - 1; ++i) &#123; for (auto j : arr[i]) &#123; cnt[j]--; if (cnt[j] == 0) &#123; if(st[j])&#123; res--; &#125; &#125; else if (!st[j]) &#123; res++; &#125; st[j] = true; &#125; if (res == 0) return i; &#125; return -1; &#125; &#125;;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"[leetcode]2552.统计上升四元组.题解O(n^2)xiaodangao","path":"/2023/03/07/[leetcode]2552. 统计上升四元组.题解O(n^2)-xiaodangao/","content":"原题链接：统计上升四元组 动态规划： 其中f[i][j]f[i][j]f[i][j]代表的是截止到当前下标为iii的数组下，大于等于jjj的个数，维护的话也是非常简单的一个线性dpdpdp，可知f[i][j]=f[i−1][j]f[i][j] = f[i-1][j]f[i][j]=f[i−1][j]当前下标下大于等于jjj的个数是大于等于下标为i−1i-1i−1状态下大于等于jjj的个数的。如果nums[i]≥jnums[i] \\ge jnums[i]≥j那么很明显f[i][j]f[i][j]f[i][j]要在f[i−1][j]f[i-1][j]f[i−1][j]的基础上加1。 维护好f[i][j]f[i][j]f[i][j]之后的工作就很简单了，枚举中间两个逆序，假设下标为j,kj,kj,k那么我们分别要寻找： x1：x1：x1：下标不超过jjj且小于nums[j]nums[j]nums[j]的个数 x2：x2：x2：下标超过kkk且大于nums[i]nums[i]nums[i]的个数 CPP代码如下 class Solution &#123; public: #define ll long long int idx = 0; int f[4010][4010]; long long countQuadruplets(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int n = len; len-=1; //f[i][j] 大于等于j的个数 for(int i=nums[0];i&gt;=0;--i)f[0][i] = 1; for(int i=1;i&lt;=len;++i)&#123; for(int j=0;j&lt;=n;++j)&#123; f[i][j] = f[i-1][j]; if(nums[i] &gt;= j)f[i][j]++; &#125; &#125; ll ans = 0; for(int i=1;i&lt;len;++i)&#123; for(int j=i+1;j&lt;len;++j)&#123; if(nums[i] &lt; nums[j])&#123; continue; &#125; int x1 = i+1-f[i][nums[j]]; int x2 = n-nums[i]+1-f[j][nums[i]]; ll res =(ll) x1 * x2; ans += res ; &#125; &#125; return ans ; &#125; &#125;;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"leetcode2564.子字符串异或查询[题解]xiaodangao","path":"/2023/03/02/leetcode 2564. 子字符串异或查询[题解]-xiaodangao/","content":"链接：子字符串异或查询 思路：题目说 val⊕first=secondval \\oplus first=secondval⊕first=second 可得val=second⊕firstval = second \\oplus firstval=second⊕first 题目变成从0−10-10−1串中找到最先出现的valvalval的二进制表示，注意是10510^5105次询问。原来认为是ACACAC自动机类的东西，但仔细一想，数字最多303030位，那么字符串sss存在的数字数量仅为10510^5105级别，那么我们可以预处理出所有数字的所在位置。 CodeCodeCode class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; substringXorQueries(string s, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123; #define ll int map&lt;ll,pair&lt;int,int &gt; &gt;S; int sz = s.size() - 1; for(int len=1;len&lt;=30;++len)&#123; for(int i=0;;++i)&#123; if(s[i] == &#x27;0&#x27; and len != 1)continue; if(i+len-1&gt;sz)break; ll now = 0; for(int j=i;j&lt;=i+len-1;++j)&#123; now &lt;&lt;= 1; if(s[j] == &#x27;1&#x27;)now += 1ll; &#125; if(S.count(now))continue; S[now] = &#123;i,i+len-1&#125;; &#125; &#125; vector&lt;vector&lt;int&gt; &gt; ans; int tot = -1; for(auto i:queries)&#123; ll res = (ll)i[0] ^ i[1]; if(S.count(res))&#123; ans.push_back(&#123;S[res].first,S[res].second&#125;); &#125;else &#123; ans.push_back(&#123;-1,-1&#125;); &#125; &#125; return ans ; &#125; &#125;;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"leetcode2565.最少得分子序列[题解]xiaodangao","path":"/2023/03/02/leetcode2565. 最少得分子序列[题解]-xiaodangao/","content":"最少得分子序列 给你两个字符串 s 和 t 。 你可以从字符串 t 中删除任意数目的字符。 如果没有从字符串 t 中删除字符，那么得分为 0 ，否则： 令 left 为删除字符中的最小下标。 令 right 为删除字符中的最大下标。 字符串的得分为 right - left + 1 。 请你返回使 t 成为 s 子序列的最小得分。 一个字符串的 子序列 是从原字符串中删除一些字符后（也可以一个也不删除），剩余字符不改变顺序得到的字符串。（比方说 “ace” 是 “abcde” 的子序列，但是 “aec” 不是）。 示例 1： 输入：s = “abacaba”, t = “bzaa” 输出：1 解释：这个例子中，我们删除下标 1 处的字符 “z” （下标从 0 开始）。 字符串 t 变为 “baa” ，它是字符串 “abacaba” 的子序列，得分为 1 - 1 + 1 = 1 。 1 是能得到的最小得分。 示例 2： 输入：s = “cde”, t = “xyz” 输出：3 解释：这个例子中，我们将下标为 0， 1 和 2 处的字符 “x” ，“y” 和 “z” 删除（下标从 0 开始）。 字符串变成 “” ，它是字符串 “cde” 的子序列，得分为 2 - 0 + 1 = 3 。 3 是能得到的最小得分。 提示： 1 &lt;= s.length, t.length &lt;= 105 s 和 t 都只包含小写英文字母。 思路：开始我们可以发现一个性质，就是一个序列t是另一个序列s的子序列，那么这就代表序列t的子序列均是序列s的子序列。因此按照题目要求，删除leftleftleft到rightrightright中的任何数量字符得到的序列，均有一子序列是删除leftleftleft到rightrightright中的所有数量字符得到的序列。那么好了，我们为了方便，就把他全删了，这样留下前缀XXX与后缀YYY,我们只需要checkcheckcheck字符串X+YX+YX+Y是否满足条件就ok。 如何checkcheckcheck前后缀是否满足呢？利用子序列自动机就可以，子序列自动机可以看作在字符串s上每一个字符均有262626个指针，f[i,j]f[i,j]f[i,j]表示字符串第iii个位置的下一个字符为′a′+j&#x27;a&#x27;+j′a′+j的下标。维护子序列自动机，实现看代码。然后利用二分来checkcheckcheck因为具有同样的子序列关系。具体看代码（也可以用双指针，我认为二分答案好写，就用的二分） CodeCodeCode class Solution &#123; public: int a[100100][26],b[100100][26],pre[33],bep[33]; void work(string s)&#123; int len = s.size() - 1; for(int i=0;i&lt;=25;++i)pre[i] = len+1; for (int i = len; i &gt;= 0; --i) &#123; int id = s[i] - &#x27;a&#x27;; for(int j=0;j&lt;=25;++j)&#123; a[i][j] = pre[j]; &#125; if(i == 0)break; pre[id] = i; &#125; for (int i = 1; i &lt;= len+1; ++i) &#123; int id = s[i] - &#x27;a&#x27;; for (int j = 0; j &lt;= 25; ++j) &#123; b[i][j] = bep[j]; &#125; if(i == len+1)break; bep[id] = i; &#125; &#125; int lens,lent ; string ss,tt ; int arr[100010],brr[100010]; bool check(int k)&#123; if(k == lent)return true; if(brr[k+1]!=0 and brr[k+1]!=lens+1)return true; if(arr[lent-k]!=0 and arr[lent-k]!=lens+1)return true; for(int i=1;;++i)&#123; int x = i,y = i+k+1; if(y&gt;lent)break; if(brr[y]==0||brr[y]==lens+1)continue; if(arr[x]==0||arr[x]==lens+1)return false; int idx = arr[x],idy = brr[y]; if(idx &lt; idy)&#123; return true; &#125; &#125; return false; &#125; int minimumScore(string s, string t) &#123; s = &quot;1&quot; + s; t = &quot;1&quot; + t;ss = s;tt = t; work(s); lens = s.size() - 1; lent = t.size() - 1; int idx = 0; for(int i=1;i&lt;=lent;++i)&#123; int num = t[i] - &#x27;a&#x27;; idx = a[idx][num]; arr[i] = idx; if(idx == 0||idx == lens+1)break; &#125; idx = lens+1; for(int i=lent;i&gt;=1;--i)&#123; int num = t[i] - &#x27;a&#x27;; idx = b[idx][num]; brr[i] = idx; if(idx == 0||idx == lens+1)break; &#125; int l = 0,r = lent; while(l &lt; r)&#123; int mid = l + r &gt;&gt; 1; if(check(mid))&#123; r = mid; &#125;else l = mid + 1; &#125; return l; &#125; &#125;;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"P3224[HNOI2012]永无乡（fhqtreap题解）xiaodangao","path":"/2022/04/22/P3224 [HNOI2012]永无乡（fhq-treap题解）-xiaodangao/","content":"《是的我又回来了》《是的我又回来了》《是的我又回来了》 题目链接：永无乡 思路：利用无旋treaptreaptreap。先看操作BBB，（因为你不能够保证一个树中的所有元素都小于另一颗树，所以不能通过merge函数将两树合并）可以这样处理，我们考虑两个fhq−treapfhq-treapfhq−treap的合并，可以参考启发式合并的思路，暴力的遍历一个较小的集合，并将其加入大的集合中。启发式合并的复杂度是均摊Θ(nlogn)\\Theta (nlogn)Θ(nlogn)。然后再看操作QQQ，那就是经典fhq−treapfhq-treapfhq−treap找第kkk大的思路。 对于快速判断属于哪一个集合，利用并查集。 CodeCodeCode const int N = 4e5+10; int fa[N],sz[N]; int found(int x)&#123; if(fa[x] == x)return fa[x]; return fa[x] = found(fa[x]); &#125; struct node &#123; int l,r; int key; int val,tag; int sz; &#125;tr[N]; int tot ,res ,n,m; int a[N]; mt19937 rnd(2884); inline int newnode(int va)&#123; tr[++tot].val = va; tr[tot].sz = 1; tr[tot].key = rnd(); return tot; &#125; int root[N] ; #define lson tr[p].l #define rson tr[p].r inline void pushup(int p)&#123; tr[p].sz = tr[lson].sz + tr[rson].sz + 1; &#125; void split(int p,int k,int &amp;x,int &amp;y)&#123; if(!p)x = y = 0; else &#123; if(tr[p].val &lt;= k)&#123; x = p; split(rson,k,rson,y); &#125;else &#123; y = p; split(lson,k,x,lson); &#125; pushup(p); &#125; &#125; int merge(int x,int y)&#123; if(!x or !y)return x + y ; if(tr[x].key &gt; tr[y].key)&#123; tr[x].r = merge(tr[x].r,y); pushup(x); return x; &#125;else &#123; tr[y].l = merge(x,tr[y].l); pushup(y); return y; &#125; &#125; int idx ; inline void ins(int va)&#123; int x,y,z; split(root[idx],va,x,y); //cout &lt;&lt; va &lt;&lt;&quot;!&quot;&lt;&lt; endl; int now = newnode(va); x = merge(x,now); root[idx] = merge(x,y); &#125; void dfs(int id)&#123; if(!id)return ; dfs(tr[id].l); ins(tr[id].val); dfs(tr[id].r); &#125; void Merge(int x,int y)&#123; //if(x == y)return ; idx = x; dfs(root[y]); sz[x] += sz[y]; fa[y] = x; &#125; int h[N]; void split_sz(int p,int k,int &amp;x,int &amp;y)&#123; if(!p)x = y = 0; else &#123; if(tr[lson].sz + 1 &lt;= k)&#123; x = p; split_sz(rson,k-tr[lson].sz-1,rson,y); &#125;else &#123; y = p; split_sz(lson,k,x,lson); &#125; pushup(p); &#125; &#125; void out(int x)&#123; if(!x)return ; out(tr[x].l); cout &lt;&lt; tr[x].val &lt;&lt; &#x27; &#x27;; out(tr[x].r); &#125; void query(int id,int k)&#123; int now = found(id); //cout &lt;&lt;sz[now]&lt;&lt;&quot;@&quot;&lt;&lt;endl; if(sz[now] &lt; k)&#123; puts(&quot;-1&quot;);return ; &#125; // k = sz[now] - k + 1; int x,y,z; split_sz(root[now],k,x,y); //cout &lt;&lt;k &lt;&lt;&quot;??&quot;&lt;&lt; x &lt;&lt;&quot;!!&quot;&lt;&lt;y&lt;&lt;endl; int idx = x; while(tr[idx].r)idx = tr[idx].r; write(h[tr[idx].val]);pc(&#x27; &#x27;); root[now] = merge(x,y); &#125; void solve()&#123; read(n);read(m); rep(i,1,n)&#123; int t ; read(t);a[i] = t;h[t] = i; &#125; rep(i,1,n)&#123; fa[i] = i;sz[i] = 1; root[i] = newnode(a[i]); &#125; //cout &lt;&lt;tr[root[2]].val&lt;&lt;endl; rep(i,1,m)&#123; int u,v; read(u);read(v); int p = found(u),q = found(v); if(p != q)&#123; if(sz[p] &lt; sz[q])swap(p,q); Merge(p,q); &#125; &#125; int idx = found(1); //out(root[idx]);cout &lt;&lt;endl; int q; read(q); while(q--)&#123; char op[33]; int x,y; scanf(&quot;%s%d%d&quot;,op,&amp;x,&amp;y); if(*op == &#x27;Q&#x27;)&#123; query(x,y); &#125;else &#123; int p = found(x),q = found(y); if(p==q)continue; if(sz[p] &lt; sz[q])swap(p,q); Merge(p,q); &#125; int now = found(1); //cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;y&lt;&lt;&quot;::::&quot;; //out(root[now]);cout &lt;&lt;endl; &#125; &#125; signed main()&#123; solve(); &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"CF1593FRedBlackNumber（记忆化搜索，动态规划）xiaodangao","path":"/2021/11/03/CF1593F Red-Black Number（记忆化搜索，动态规划）-xiaodangao/","content":"Red-Black Number 思路：我们发现每个格子有两种染色方式，所以一共是2402^{40}240种，不能通过，想到可以进行折半搜索，每次2202^{20}220种，然后再进行整合答案，能够通过。但有一种规模更小的搜索方法。我们设f(i,j,k,t)f(i,j,k,t)f(i,j,k,t)表示当前进行到第iii个，当前被染红的格子的十进制表示modAmodAmodA 的值为jjj，染黑的格子的十进制表示modBmodBmodB的值为kkk，当前有ttt个红格子的状态是否可行。 考虑搜索，即 f(i,j,k,t)−&gt;f(i+1,(j∗10+s[i+1])moda,k,t+1)f(i,j,k,t) -&gt;f(i+1,(j*10+s[i+1])moda,k,t+1)f(i,j,k,t)−&gt;f(i+1,(j∗10+s[i+1])moda,k,t+1) f(i,j,k,t)−&gt;f(i+1,j,(k∗10+s[i+1])modb,t)f(i,j,k,t)-&gt;f(i+1,j,(k*10+s[i+1])modb,t)f(i,j,k,t)−&gt;f(i+1,j,(k∗10+s[i+1])modb,t) 然后统计一下答案即可。 Code:Code:Code: const int N = 33+10; char s[N]; int _; int a,b,n; int ans = 99999; bool st[N][N][N][N]; //int head[N][N][N][N]; vector&lt;int&gt;G,Ans; void dfs(int id,int j,int k,int t)&#123; if(st[id][j][k][t] == 1)return; if(id == n and j == 0 and k == 0 and t != 0 and t != n)&#123; int now = abs(t - (n - t)); if(ans &gt; now)&#123; Ans.clear();Ans = G; //for(auto i:Ans)printf(&quot;%d&quot;,i);pc(&#x27; &#x27;); ans = now;return ; &#125; &#125; st[id][j][k][t] = 1; if(id == n)return ; int num = s[id+1] - &#x27;0&#x27;; int x = (num + j * 10)%a; int y = (num + k * 10)%b; //head[id+1][x][k][t+1] = G.pb(id+1); dfs(id+1,x,k,t+1); G.pop_back(); dfs(id+1,j,y,t); &#125; bool col[N]; void solve()&#123; read(_); while(_--)&#123; ans = 99999; memset(st,false,sizeof st); memset(col,false,sizeof col); G.clear(); read(n);read(a);read(b); scanf(&quot;%s&quot;,s+1); dfs(0,0,0,0); //write(ans);pc(&#x27; &#x27;); if(ans == 99999)&#123;puts(&quot;-1&quot;); &#125; else &#123; for(auto i:Ans)col[i] = true; for(int i=1;i&lt;=n;++i)pc(col[i]?&#x27;R&#x27;:&#x27;B&#x27;); pc(&#x27; &#x27;); &#125; &#125; &#125; 这道题告诉我，当我们面对这种搜索规模偏大的情况下，我们可以考虑运用记忆化搜索 + 设定变换维度 ，来达到缩小搜索规模的目的。当动态规划方程不太直观时，我们可以转为运用记忆化搜索，从前向后更新状态，这样在某些题中更为直观自然。","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"POJ3124.TheBookcase（题解）xiaodangao","path":"/2021/10/22/POJ3124.The Bookcase（题解）-xiaodangao/","content":"思路：我们发现一共需要求两维东西，一个是宽度，另一个是高度，那么依据我们的经验，可以将高度首先进行一次排序。那么是由高到低排好，还是由低到高排好呢？ 考虑由低到高，显然每一次加入一个东西iii时，该东西一定是最高的，该东西加入的那一排，高度一定是h[i]h[i]h[i]，但是有一个问题是我们还需要知道其他两维的高度，那么我们必须再开两维数组来表示，显然解决了一部分问题，但是并不能完全解决问题。 考虑由高到低，由高到低一个最大的好处就是，这三排中的MaxhighMax_highMaxh​igh一定在头部，此时我们如果用数组来表示宽度的话，那么如果宽度不为0，就代表这一排前面一定有比这个高的，高度不会改变，所以我们能够用一维来表示两维能表示的东西，很好的解决了这个问题。 因为我们需要求最小面积 = ∑Max_high∗∑Max_width\\sum Max\\_high * \\sum Max\\_width∑Max_high∗∑Max_width，又发现了宽度可以继续表示高度，那么我们就设f(i,j,k)f(i,j,k)f(i,j,k)代表当前进行到第iii个物品，且第一排第二排宽度分别为j,kj,kj,k时最小高度，状态转移方程： f[i,j,k]=min(f[i−1,j,k]+(sum_now−j−k==0?h[i]:0),f[i−1,j−w[i],k]+(j−w[i]==0?h[i]:0),f[i−1,j,k−w[i]]+(k−w[i]==0?h[i]:0))f[i,j,k] = min(f[i-1,j,k] + (sum\\_now - j - k == 0?h[i]:0),f[i-1,j-w[i],k] + (j-w[i] == 0?h[i]:0),f[i-1,j,k-w[i]] + (k-w[i] == 0?h[i]:0))f[i,j,k]=min(f[i−1,j,k]+(sum_now−j−k==0?h[i]:0),f[i−1,j−w[i],k]+(j−w[i]==0?h[i]:0),f[i−1,j,k−w[i]]+(k−w[i]==0?h[i]:0)) 最后扫描一遍原数组得到答案。 这个题我们需要做到两维才能够AC，发现转移方程中iii是由i−1i-1i−1转移，那么一个显而易见的想法是开滚动数组~~（然而我还是过不了~~，因此后两维枚举时倒着枚举，这样就能够AC了。详情见代码： Code:Code:Code: #include &lt;algorithm&gt; #include &lt;bitset&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;deque&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;string&gt; #include &lt;vector&gt; #define ch() getchar() #define pc(x) putchar(x) #define rep(i, a, b) for (int i = a; i &lt;= b; ++i) #define bep(i, a, b) for (int i = a; i &gt;= b; --i) #define lowbit(x) x &amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template &lt;typename T&gt; void read(T &amp;x) &#123; static char c; static int f; for (c = ch(), f = 1; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c = ch()) if (c == &#x27;-&#x27;) f = -f; for (x = 0; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = ch()) x = x * 10 + (c &amp; 15); x *= f; &#125; template &lt;typename T&gt; void write(T x) &#123; static char q[65]; int cnt = 0; if (x &lt; 0) pc(&#x27;-&#x27;), x = -x; q[++cnt] = x % 10, x /= 10; while (x) q[++cnt] = x % 10, x /= 10; while (cnt) pc(q[cnt--] + &#x27;0&#x27;); &#125; const int N = 2130; int _, n; int f[N][N]; struct node &#123; int h, t; bool operator&lt;(const node &amp;a) const &#123; return a.h &lt; h; &#125; &#125; a[N]; void solve() &#123; read(_); // memset(f,0x3f,sizeof f); while (_--) &#123; read(n); int sum = 0; // memset(f, 0x3f, sizeof f); int sums = 0; f[0][0] = 0; rep(i, 1, n) &#123; int x, y; read(x); read(y); sums += y; a[i].h = x; a[i].t = y; &#125; memset(f,0x3f,sizeof f); f[0][0] = 0; sort(a + 1, a + 1 + n); int ans = 99999999; rep(i, 2, n) &#123; // printf(&quot;%d &quot;,a[i].h); //sum += a[i].t; bep(j, sums, 0) &#123; for (int k = sums; k &gt;= 0; --k) &#123; //int &amp;res = f[j][k]; if(f[j][k] == 0x3f3f3f3f or j+k &gt; sums)continue; f[j + a[i].t][k] = min(f[j + a[i].t][k], f[j][k] + (j == 0 ? a[i].h : 0)); f[j][k + a[i].t] = min( f[j][k + a[i].t], f[j][k] + (k == 0 ? a[i].h : 0)); //res = 0x3f3f3f3f; // if (j - a[i].t &gt;= 0) // res = min( // res, f[j - a[i].t][k] + (j == a[i].t ? a[i].h : 0)); // if (k - a[i].t &gt;= 0) // res = min( // res, f[j][k - a[i].t] + (k == a[i].t ? a[i].h : 0)); // res = min(res, // f[j][k] + (sum - (j + k) == a[i].t ? a[i].h : 0)); &#125; &#125; sum += a[i].t; &#125; rep(i, 1, sums) &#123; rep(j, 1, sums) &#123; if (f[i][j] &gt;= 0x3f3f3f3f or i + j &gt;= sums) continue; // printf(&quot;&#123;%d %d %d&#125; %d %d %d &quot;,i,j,sum-i-j,f[n][i][j], // max(&#123;i,j,sum-i-j&#125;),f[n][i][j] * max(&#123;i,j,sum-i-j&#125;)); ans = min((f[i][j] + a[1].h) * max(max(i, j), sums - i - j), ans); // f[0][i][j] = f[1][i][j] = 0x3f3f3f3f; &#125; &#125; write(ans); pc(&#x27; &#x27;); &#125; &#125; signed main(int argc, char const *argv[]) &#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"EducationalCodeforcesRound115(RatedforDiv.2)（题解）xiaodangao","path":"/2021/10/20/Educational Codeforces Round 115 (Rated for Div. 2)（题解）-xiaodangao/","content":"###Educational Codeforces Round 115 (Rated for Div. 2) #####A - Computer Game 思路：dfs暴力搜索。 Code:Code:Code: const int N = 1010; int _,n; char a[3][N]; bool st[3][N]; int l[] = &#123;0,0,-1,1,1,1,-1,-1&#125;,r[] = &#123;1,-1,0,0,1,-1,1,-1&#125;; void dfs(int x,int y)&#123; st[x][y] = true; for(int i=0;i&lt;=7;++i)&#123; int idx = l[i] + x,idy = r[i] + y; if(idx &gt; 2 or idx &lt;= 0 or idy &gt; n or idy &lt;= 0)continue; if(st[idx][idy])continue; if(a[idx][idy] == &#x27;1&#x27;)continue; dfs(idx,idy); &#125; &#125; void solve()&#123; read(_); while(_--)&#123; read(n); memset(a,-1,sizeof a); memset(st,0,sizeof st); scanf(&quot;%s%s&quot;,a[1]+1,a[2]+1); if(a[1][1] == &#x27;0&#x27;) dfs(1,1); if(st[2][n] == 1)puts(&quot;YES&quot;);else puts(&quot;NO&quot;); &#125; &#125; B - Groups 思路：暴力枚举答案，然后设答案为(l,r)(l,r)(l,r) 那么检测答案是否合法。只有当所有人都至少在(l,r)(l,r)(l,r)其中一天内有空，并且在这两天有空的总人数均大于等于n2\\frac{n}{2}2n​ ，那么答案就合法。如果不理解可以自己画图感受一下。 Code:Code:Code: const int N = 100100; int _,n; int a[N][6]; bool st[33]; int l[] = &#123;0,0,-1,1,1,1,-1,-1&#125;,r[] = &#123;1,-1,0,0,1,-1,1,-1&#125;; void solve()&#123; read(_); while(_--)&#123; read(n); rep(i,1,n)&#123; rep(j,1,5)&#123; read(a[i][j]); &#125; &#125; bool flag = false; for(int i=1;i&lt;(1&lt;&lt;5);++i)&#123; int cnt = 0; int now[55],hh = 0; for(int j=0;j&lt;=4;++j)&#123; if((i&gt;&gt;j)&amp;1)&#123; now[++hh] = j+1;cnt++; &#125; &#125; bool judge = true; int x[33];x[1] = x[2] = 0; if(cnt == 2)&#123; //rep(j,0,4)write((i&gt;&gt;j)&amp;1);pc(&#x27; &#x27;); for(int j=1;j&lt;=n;++j)&#123; if(!a[j][now[1]] and !a[j][now[2]])&#123; judge = false;break; &#125; x[1] += (a[j][now[1]] == 1); x[2] += (a[j][now[2]] == 1); &#125; &#125;else continue; if(x[1] &lt; n/2 or x[2] &lt; n/2)judge = false; if(judge)&#123;flag = true;break;&#125; &#125; if(flag)puts(&quot;YES&quot;);else puts(&quot;NO&quot;); &#125; &#125; C - Delete Two Elements 思路：因为他让选择两个数，我们首先判断是否有答案，由平均数定义可得： ∑1na[i]n=a[x]+a[y]2\\frac{\\sum_1^n a[i]}{n} = \\frac{a[x] + a[y]}{2} n∑1n​a[i]​=2a[x]+a[y]​ 所以： a[x]+a[y]=2∑1na[i]na[x] + a[y] = \\frac{2\\sum_1^na[i]}{n} a[x]+a[y]=n2∑1n​a[i]​ 因为数组aaa是整数，那么首先判断是否a[x]+a[y]a[x] + a[y]a[x]+a[y]可以为整数，然后开个桶记录所有个数，依次枚举每一个a[i]a[i]a[i]作为答案。即可得到答案 复杂度O(nlogn)O(nlogn)O(nlogn) Code:Code:Code: const int N = 200100; int _,n; ll a[N]; bool st[33]; int l[] = &#123;0,0,-1,1,1,1,-1,-1&#125;,r[] = &#123;1,-1,0,0,1,-1,1,-1&#125;; map&lt;ll,ll&gt;S; void solve()&#123; read(_); while(_--)&#123; S.clear(); read(n); ll Sum = 0ll; rep(i,1,n)&#123; read(a[i]);S[a[i]]++; Sum += a[i]; &#125; if((Sum * (2ll))%n)&#123; puts(&quot;0&quot;);continue; &#125; ll x = (Sum * (2ll))/n; //printf(&quot;%lld &quot;,x); ll ans = 0; rep(i,1,n)&#123; ll now = x - a[i] ; ll res = S[now]; if(now == a[i])&#123; res--; &#125; ans+=res; &#125; write(ans/2);pc(&#x27; &#x27;); &#125; &#125; D - Training Session 思路：这个题是让我们选合法三元组数，那么正难则反，我们考虑不符合的个数。首先我们发现如果三元组有一个属性全部相同，那么该三元组一定合法。比如属性A[x,x,x]A[x,x,x]A[x,x,x] ，那么属性BBB一定是不相同的，因为如果相同就不满足题目所给限制：任意两个问题AAA属性和BBB属性至少有一个不同。那么我们不符合的个数里只有这种形式A[x,x,y]，B[a,b,b]A[x,x,y]，B[a,b,b]A[x,x,y]，B[a,b,b]，即两个属性是两个相同的，那我们发现我们可以枚举作为中间的，因为在中间的元素右边必定与其AAA属性相同，左边必定与其BBB属性相同，开个桶分别记录两个属性满足的个数，所以不符合的个数应该是两边相乘得到的结果。最后用总个数减去不符合的个数。 复杂度O(n)O(n)O(n) Code:Code:Code: const int N = 200100; int _,n; ll a[N]; bool st[33]; int l[N],r[N]; map&lt;ll,ll&gt;S; pair&lt;int,int&gt;arr[N]; void solve()&#123; read(_); while(_--)&#123; read(n); fill(l,l+1+n,0);fill(r,r+1+n,0); ll sum = (1ll *n*(n-1)*(n-2))/6; rep(i,1,n)&#123; int x,y; read(x);read(y); l[x]++;r[y]++; arr[i] = &#123;x,y&#125;; &#125; ll res = 0ll; rep(i,1,n)&#123; int x = arr[i].first,y = arr[i].second; res += 1ll*(l[x]-1)*(r[y]-1); &#125; write(sum-res);pc(&#x27; &#x27;); &#125; &#125; E - Staircases 思路：这个题感觉比较好想，重点应该在代码实现上，将梯子向上、向下搜索。然后在第一个不自由的格子停住，然后相乘维护答案。因为询问10410^4104，并且每次询问暴力复杂度为O(n)O(n)O(n) 总复杂度为O(n∗q)O(n*q)O(n∗q) ，可以通过。 Code:Code:Code: const int N = 1010; int _, n, m, q; bool st[N][N]; ll a[N]; int l[] = &#123;-1, 0, 1, 0&#125;, r[] = &#123;0, -1, 0, 1&#125;; ll ans; void work(int x, int y) &#123; // 2~3 1~4 int idx = x, idy = y; ll a1 = 0, a2 = 0, b1 = 0, b2 = 0; int now = 0; bool tmp = st[x][y]; st[x][y] = false; while (idx &gt;= 1 and idx &lt;= n and idy &gt;= 1 and idy &lt;= m and st[idx][idy] == false) &#123; a1++; idx += l[now]; idy += r[now]; now++; if (now &gt;= 2) now = 0; &#125; now = 1; idx = x, idy = y; while (idx &gt;= 1 and idx &lt;= n and idy &gt;= 1 and idy &lt;= m and st[idx][idy] == false) &#123; a2++; idx += l[now]; idy += r[now]; now++; if (now &gt;= 2) now = 0; &#125; now = 2; idx = x, idy = y; while (idx &gt;= 1 and idx &lt;= n and idy &gt;= 1 and idy &lt;= m and st[idx][idy] == false) &#123; b2++; idx += l[now]; idy += r[now]; now++; if (now &gt;= 4) now = 2; &#125; idx = x; idy = y; now = 3; while (idx &gt;= 1 and idx &lt;= n and idy &gt;= 1 and idy &lt;= m and st[idx][idy] == false) &#123; b1++; idx += l[now]; idy += r[now]; now++; if (now &gt;= 4) now = 2; &#125; if (tmp == true) &#123; ans += a1 * b1 + a2 * b2 - 1; &#125; else &#123; ans -= a1 * b1 + a2 * b2 - 1; &#125; st[x][y] = !tmp; &#125; void solve() &#123; read(n); read(m); read(q); rep(i, 1, max(n, m)) &#123; ll x1 = max(1ll * (n - i + 1) * (m - i + 1), 0ll); if (i != 1) x1 *= 2ll; ll x2 = max(1ll * (n - i + 1) * (m - (i + 1) + 1), 0ll) + max(0ll, 1ll * (n - (i + 1) + 1) * (m - i + 1)); // printf(&quot;%d:: %lld %lld &quot;,i,x1,x2); ans += x1 + x2; &#125; rep(test, 1, q) &#123; int x,y; read(x);read(y); work(x,y); write(ans);pc(&#x27; &#x27;); &#125; &#125; F - RBS 思路：我们定义$ “(”$的权值为1， &quot;)&quot;&quot;)&quot;&quot;)&quot;的权值为-1。我们定义合法字符串sss为sss的所有前缀的权值和的最小值大于等于0。只有合法字符串才能够更新答案，否则该字符串的答案就已经确定了，就没必要再进行更新。 例如：(()))(()))(()))是一个非法字符串，(())((())((())(是一个合法字符串。 考虑动态规划，因为最多只有20个串，所以我们可以用二进制010101来表示集合。设f[i]f[i]f[i]表示选择集合iii的最佳答案。我们再维护一个ggg数组，表示在当前集合取最佳答案时的权值和为多少。特别的，如果为非法字符串，那么g[i]=−1g[i] = -1g[i]=−1。考虑转移，根据一般动态规划特性，我们应该枚举该集合中哪一个串是出现在最后。然后用这个来更新答案。我们假设枚举的串编号为ttt 那么我们转移的集合应该是i⨁(1&lt;&lt;t)i \\bigoplus (1&lt;&lt;t)i⨁(1&lt;&lt;t)，那么分类讨论： g[i⨁(1&lt;&lt;t)]=−1g[i \\bigoplus (1&lt;&lt;t)] = -1g[i⨁(1&lt;&lt;t)]=−1，那么说明已经是非法字符串了，答案不会再增加，所以不用转移。 g[i⨁(1&lt;&lt;t)]+min[t]&lt;0g[i\\bigoplus(1&lt;&lt;t)] + min[t] &lt; 0g[i⨁(1&lt;&lt;t)]+min[t]&lt;0，注：这里的min[t]min[t]min[t]是指字符串ttt的最小前缀和。那么这表明，虽然1⨁(1&lt;&lt;t)1\\bigoplus(1&lt;&lt;t)1⨁(1&lt;&lt;t)并不是非法字符串，但是最后加入字符串ttt之后，就变成了非法字符串，那么我们可以更新ansansans ,维护两个桶，第一个桶简单代表前缀和的出现次数，第二个桶代表第一次出现比iii小的前缀和时，iii的个数。我们这里主要是用第二个桶来完成更新。因为我们已经知道该集合的权值和，那么又知道了经过这一次更新，将变为非法字符串，那么在字符串ttt中，肯定有一个位置，在这个位置之前，原串是合法字符串，在这个位置之后，原串是非法字符串，那我们第二个桶记录iii总是在第一个桶第一次记录i−1i-1i−1时，就是表明在前缀和最低降到iii时，有多少个位置的前缀和为iii。我们不难写出转移方程sum=f[i⨁(1&lt;&lt;t)]+S2[t][−g[i⨁(1&lt;&lt;t)]]sum = f[i\\bigoplus(1&lt;&lt;t)] + S2[t][-g[i\\bigoplus(1&lt;&lt;t)]]sum=f[i⨁(1&lt;&lt;t)]+S2[t][−g[i⨁(1&lt;&lt;t)]] 。 g[1⨁(1&lt;&lt;t]+min[t]≥0g[1\\bigoplus(1&lt;&lt;t] + min[t] \\geq 0g[1⨁(1&lt;&lt;t]+min[t]≥0 ，这说明经过这轮更新之后，依旧是合法字符串，那么我们可以更新该字符串的f,gf,gf,g数组，并且用第一个桶进行维护答案。 因为维护桶用的是unorderedmapunorderedmapunorderedmap，所以复杂度O(n220)O(n2^{20})O(n220) Code:Code:Code: string a[33]; int n; int mi[33], Sum[33]; int f[(1 &lt;&lt; 21)], g[(1 &lt;&lt; 21)]; unordered_map&lt;int, int&gt; S1[22], S2[22]; void solve() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; rep(i, 0, n - 1) &#123; cin &gt;&gt; a[i]; int now = 0; for (auto j : a[i]) &#123; if (j == &#x27;(&#x27;) now++; else now--; mi[i] = min(mi[i], now); //记录前缀个数 S1[i][now]++; //记录第一次不能统计now+1时的数量 if (S1[i][now] == 1) &#123; S2[i][now + 1] = S1[i][now + 1]; &#125; &#125; Sum[i] = now; &#125; int ans = 0; for (int i = 1; i &lt; (1 &lt;&lt; n); ++i) &#123; g[i] = -1; //枚举第j个做集合i的最后一个字符串 for (int j = 0; j &lt; n; ++j) &#123; if ((i &gt;&gt; j) &amp; 1) &#123; int id = i ^ (1 &lt;&lt; j); if (g[id] &lt; 0) &#123; continue; &#125; else if (g[id] + mi[j] &lt; 0) &#123; int sum = S2[j][-g[id]] + f[id]; ans = max(ans, sum); &#125; else &#123; int res = S1[j][-g[id]] + f[id]; if (f[i] &lt; res) &#123; f[i] = res; &#125;g[i] = Sum[j] + g[id]; ans = max(ans,f[i]); &#125; &#125; &#125; &#125; write(ans);pc(&#x27; &#x27;); &#125; The Sum of Good Numbers 思路：设A+B=XA+B=XA+B=X且A≥BA \\geq BA≥B，那么A,BA,BA,B的长度可以有以下几种 ∣A∣=∣X∣−1,∣B∣=∣X∣−1|A| = |X|-1,|B| = |X|-1∣A∣=∣X∣−1,∣B∣=∣X∣−1 ∣A∣=∣X∣|A| = |X|∣A∣=∣X∣ 那么第一种情况，我们可以枚举在aaa串中所有长度为∣X∣−1|X|-1∣X∣−1的串来作为答案。重点考虑第二种情况，我们枚举所有长度为∣X∣|X|∣X∣的串为AAA来判断，我们可以发现确定A,XA,XA,X之后，BBB的长度其实是由XXX与AAA的最长公共前缀决定的，因为没有000的存在，所以∣A∣−lcp(A,X)len|A|-lcp(A,X)_{len}∣A∣−lcp(A,X)len​即为BBB的长度，在确定BBB的长度以及BBB的位置后，我们可以取出BBB来进行判断。BBB长度可以在∣A∣−lcp(A,X)len±2|A|-lcp(A,X)_{len} \\pm2∣A∣−lcp(A,X)len​±2的范围内都试一下。 那么我们取出A,BA,BA,B之后，接下来需要判断A+BA+BA+B是否等于XXX，高精度复杂度O(n2)O(n^2)O(n2)明显不行，我们发现可以利用字符串哈希的方式O(1)O(1)O(1)的判断是否合法。问题就解决了。 复杂度O(n)O(n)O(n) （摆烂了，代码不写了","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"P6327区间加区间sin和（题解）xiaodangao","path":"/2021/10/11/P6327 区间加区间sin和（题解）-xiaodangao/","content":"思路：根据sinsinsin ，coscoscos的运算来做。我们有： sin(a+b)=sin(a)∗cos(b)+sin(b)∗cos(a)sin(a+b) = sin(a) * cos(b) + sin(b)*cos(a) sin(a+b)=sin(a)∗cos(b)+sin(b)∗cos(a) cos(a+b)=cos(a)∗cos(b)−sin(a)∗sin(b)cos(a+b) = cos(a) * cos(b) - sin(a) * sin(b) cos(a+b)=cos(a)∗cos(b)−sin(a)∗sin(b) 所以线段树维护每个节点的sinsinsin，coscoscos 就能得到答案，需要注意的是懒标记应开longlonglonglonglonglong Code:Code:Code: #include &lt;algorithm&gt; #include &lt;bitset&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;deque&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;string&gt; #include &lt;unordered_map&gt; #include &lt;vector&gt; #define ch() getchar() #define pc(x) putchar(x) #define rep(i, a, b) for (auto i = a; i &lt;= b; ++i) #define bep(i, a, b) for (auto i = a; i &gt;= b; --i) #define lowbit(x) x &amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template &lt;typename T&gt; void read(T &amp;x) &#123; static char c; static int f; for (c = ch(), f = 1; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c = ch()) if (c == &#x27;-&#x27;) f = -f; for (x = 0; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = ch()) x = x * 10 + (c &amp; 15); x *= f; &#125; template &lt;typename T&gt; void write(T x) &#123; static char q[65]; int cnt = 0; if (x &lt; 0) pc(&#x27;-&#x27;), x = -x; q[++cnt] = x % 10, x /= 10; while (x) q[++cnt] = x % 10, x /= 10; while (cnt) pc(q[cnt--] + &#x27;0&#x27;); &#125; const int N = 2e5 + 10; int n; int a[N]; struct segmentTree &#123; struct node &#123; int l, r, L, R; ll add; double sina, cosa; &#125; tr[N &lt;&lt; 3]; inline void update(int u, double sinx, double cosx) &#123; double sins = tr[u].sina, coss = tr[u].cosa; tr[u].sina = sins * cosx + coss * sinx; tr[u].cosa = coss * cosx - sins * sinx; &#125; inline void pushup(int p) &#123; tr[p].sina = tr[tr[p].l].sina + tr[tr[p].r].sina; // + // tr[tr[p].r].sina * tr[tr[p].l].cosa); tr[p].cosa = tr[tr[p].l].cosa + tr[tr[p].r].cosa; &#125; inline void pushdown(int p) &#123; if (tr[p].add != 0) &#123; ll d = tr[p].add; tr[p].add = 0; double rs = tr[tr[p].r].sina, ls = tr[tr[p].l].sina; (tr[tr[p].r].sina = sin(d) * tr[tr[p].r].cosa + tr[tr[p].r].sina * cos(d)); (tr[tr[p].r].cosa = cos(d) * tr[tr[p].r].cosa - rs * sin(d)); (tr[tr[p].l].sina = sin(d) * tr[tr[p].l].cosa + tr[tr[p].l].sina * cos(d)); (tr[tr[p].l].cosa = cos(d) * tr[tr[p].l].cosa - ls * sin(d)); (tr[tr[p].l].add += d); (tr[tr[p].r].add += d); &#125; &#125; inline void build(int l, int r, int p) &#123; tr[p].l = p &lt;&lt; 1; tr[p].r = p &lt;&lt; 1 | 1; tr[p].L = l, tr[p].R = r; tr[p].add = 0; if (l == r) &#123; tr[p].sina = sin(a[l]), tr[p].add = 0; tr[p].cosa = cos(a[l]); // printf(&quot;%d %d %.3lf &quot;, tr[p].L, tr[p].R, tr[p].sina); return; &#125; int mid = l + r &gt;&gt; 1; build(l, mid, tr[p].l), build(mid + 1, r, tr[p].r); pushup(p); // printf(&quot;%d %d %.1lf &quot;,tr[p].L,tr[p].R,tr[p].sina); &#125; inline void add(int l, int r, int p, int k) &#123; if (tr[p].L &gt;= l &amp;&amp; tr[p].R &lt;= r) &#123; double ps = tr[p].sina; tr[p].sina = tr[p].sina * cos(k) + tr[p].cosa * sin(k); tr[p].cosa = tr[p].cosa * cos(k) - ps * sin(k); tr[p].add += k; return; &#125; pushdown(p); if (tr[tr[p].l].R &gt;= l) add(l, r, tr[p].l, k); if (tr[tr[p].r].L &lt;= r) add(l, r, tr[p].r, k); pushup(p); &#125; inline double ask(int l, int r, int p) &#123; double ret = 0.0; pushdown(p); if (tr[p].L &gt;= l &amp;&amp; tr[p].R &lt;= r) &#123; // printf(&quot;~~%.1lf %.1lf &quot;, tr[p].sina, tr[p].cosa); return tr[p].sina; &#125; if (tr[tr[p].l].R &gt;= l) &#123; (ret = ask(l, r, tr[p].l)); // printf(&quot;~##!!!%d %d %.1lf &quot;, tr[p].L, tr[p].R, ret.first); &#125; if (tr[tr[p].r].L &lt;= r) &#123; ret += ask(l,r,tr[p].r); // printf(&quot;~#!!!%d %d %.1lf &quot;, tr[p].L, tr[p].R, ret.first); &#125; // printf(&quot;~!!!%d %d %.1lf &quot;, tr[p].L, tr[p].R, ret.first); return ret; &#125; &#125; T; int q; void solve() &#123; read(n); rep(i, 1, n) read(a[i]); T.build(1, n, 1); // printf(&quot;%.1lf &quot;, T.ask(3, 3, 1).first); read(q); while (q--) &#123; int v, op, l, r; read(op); read(l); read(r); if (op == 1) &#123; read(v); T.add(l, r, 1, v); &#125; else &#123; printf(&quot;%.1lf &quot;, T.ask(l, r, 1)); &#125; &#125; &#125; signed main(int argc, char const *argv[]) &#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"CodeforcesRound#729(Div.2)题解xiaodangao","path":"/2021/07/07/Codeforces Round #729 (Div. 2)题解-xiaodangao/","content":"Codeforces Round #729 (Div. 2) A - Odd Set 思路：理解了题意基本上就能做了，模拟一下。 CodeCodeCode /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : F.cpp @Time : 2021/07/02 08:32:34 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e5+10; int _,n; void solve()&#123; read(_); while(_--)&#123; read(n); int cnt=0; rep(i,1,2*n)&#123; int x; read(x); if(x%2)cnt++; &#125; if(cnt == n)puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; signed main()&#123;solve();return 0; &#125; ####B - Plus and Multiply 思路：贪心，我们发现，一个数如果在集合中，那么一定能表示成 ak+pba^k + pbak+pb的形式。直接枚举指数 kkk CodeCodeCode /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : F.cpp @Time : 2021/07/02 08:32:34 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x) &#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x) &#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e5+10; const ll mod = 998244353; int _,n; map&lt;ll,pair&lt;ll,ll&gt; &gt; S; vector&lt;ll&gt;G; map&lt;ll,ll&gt;cnt; void solve() &#123; scanf(&quot;%d&quot;, &amp;_); while (_--) &#123; ll cnts, x, y; scanf(&quot;%lld%lld%lld&quot;, &amp;cnts, &amp;x, &amp;y); if (x == 1) &#123; if (!((cnts - 1) % y)) &#123; puts(&quot;Yes&quot;); &#125; else puts(&quot;No&quot;); &#125; else &#123; bool flag = false; ll cur = 1ll; while (cur &lt;= cnts) &#123; if ((cnts - cur) % y == 0) &#123; flag = true; break; &#125; cur = cur * x; &#125; if (flag) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; &#125; signed main() &#123; solve(); return 0; &#125; C - Strange Function 思路：枚举答案，我们从 222 开始枚举答案，算一下在范围[1,n][1,n][1,n]里，答案为 222 的共有多少个，然后再算答案为 333 的，答案为 444 的，现在我们假设算到答案为 kkk ，我们看一下如何求出范围在 [1,n][1,n][1,n] 里且答案为 kkk 的数有多少个。设一个从一开始就维护的前缀 nownownow，这个前缀是代表我们算到答案为 kkk **这个数的因数中一定要有 nownownow ** 且 nownownow 一定是最小的满足条件的那一个。那么我们先假设我们知道了 nownownow 该怎么计算当前的答案。我们发现 cnt1=⌊nnow⌋cnt1=\\lfloor \\frac{n}{now} \\rfloorcnt1=⌊nown​⌋ 代表在 [1,n][1,n][1,n] 范围里以 nownownow 为因子的个数，但这并不是答案，因为他可能满足被当前的 nownownow 整除的前提下，被下一个 nownownow 也整除，这就会导致答案计算重复，所以我们要减去一个在 [1,cnt1][1,cnt1][1,cnt1] 中且能被下一个 nownownow 整除的。我们发现，假如我们设 gcd(now,k)=1gcd(now,k)=1gcd(now,k)=1时，那么在 [1,cnt1][1,cnt1][1,cnt1] 中只要不被 kkk 整除就可以了，我们发现在 1[1,cnt1]1[1,cnt1]1[1,cnt1] 中被 kkk 整除的数有 cnt2=⌊cnt1k⌋cnt2 = \\lfloor \\frac{cnt1}{k} \\rfloorcnt2=⌊kcnt1​⌋ 个，所以答案为 kkk 的个数就是 cnt1−cnt2cnt1-cnt2cnt1−cnt2 。那么我们考虑如果 gcd(now,k)≠1gcd(now,k) eq 1gcd(now,k)​=1 时答案。gcd(now,k)≠1gcd(now,k) eq 1gcd(now,k)​=1 我们可以将 kkk 变为 kgcd(now,k)\\frac{k}{gcd(now,k)}gcd(now,k)k​ 这样一来，gcdgcdgcd就变为 111 了。 还有一个问题是 nownownow 的转移，和刚才那个操作很像，设当前进行枚举的答案是 valvalval ，那么 now=now∗valgcd(now,val)now = \\frac{now*val}{gcd(now,val)}now=gcd(now,val)now∗val​ 就是 lcm(now,val)lcm(now,val)lcm(now,val) 。 可以发现枚举答案的话每一次转移是 O(1)O(1)O(1) 然后最大答案不超过 505050 的样子。 Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : C.cpp @Time : 2021/07/05 11:00:31 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const ll mod = 1e9+7; int _; ll x; ll qpow(ll a,ll b)&#123; ll res = 1ll; while(b)&#123; if(b&amp;1)&#123;res *= a;res %= mod; &#125; b&gt;&gt;=1; a*=a; a%=mod; &#125; return res ; &#125; ll inv(ll a)&#123; return qpow(a,mod-2); &#125; void solve()&#123; read(_); while(_--)&#123; read(x); ll now = 1ll; ll id = 2ll; ll ans = 0ll; //\t一个数x，y //\tll cnt = 0ll; while(now &lt;= x)&#123; ll k = x/now; ll f = __gcd(now,id); ll p = id / f; ll cnt = k - k/p; //printf(&quot;%lld %lld %lld %lld &quot;,id-1,cnt,now,f); //cnt += k-k/id; //k = (k%mod + mod) %mod; ans += cnt * id; ans %= mod; now *= id/__gcd(now,id); //now *= id; id++; //id %= mod; &#125; //\tprintf(&quot;%lld &quot;,now); write(ans);pc(&#x27; &#x27;); &#125; &#125; signed main()&#123;solve();return 0;&#125; D - Priority Queue 思路：我们考虑每一个值在全部集合中能出现多少次，对于每一个 axa_xax​ 进行 dpdpdp （如果是 “−”“-”“−” 那么设当前 ax=−1a_x = -1ax​=−1），设 f(i,j)f(i,j)f(i,j) 代表当前进行到第 iii 个数，且前面有 jjj 个比 axa_xax​ 要小的数。考虑转移： 如果当前 ai=−1a_i = -1ai​=−1 的话，那么如果不选当前的 &quot;−&quot;&quot;-&quot;&quot;−&quot; ，有 f(i−1,j)f(i-1,j)f(i−1,j) 种方案，如果选择当前的&quot;−&quot;&quot;-&quot;&quot;−&quot; 那么有$ f(i-1,j+1)$ 种方案数 ，特别的，如果 j=0j = 0j=0 且 i&lt;xi &lt; xi&lt;x 再额外加上一个 f(i−1,j)f(i-1,j)f(i−1,j) ，这个可以这样理解，当 j=0j=0j=0 且 i&lt;xi&lt;xi&lt;x 时，我们选择当前的 &quot;−&quot;&quot;-&quot;&quot;−&quot; ，f(i−1,j)f(i-1,j)f(i−1,j) 中包括的方案数中，可以根据空集和非空集将他们分为两种，我们先看空集，如果当前为空集的话，”−“”-“”−“ 并不会影响什么，f(i−1,j)f(i-1,j)f(i−1,j) 的空集部分是可以算进 f(i,j)f(i,j)f(i,j) 内的，那么我们看如果当前为非空集的话，又因为 i&lt;xi&lt;xi&lt;x ，所以减掉一个比 axa_xax​ 大的数并没有影响 axa_xax​ 的贡献，所以 f(i−1,j)f(i-1,j)f(i−1,j) 的非空集部分也是可以算进 f(i,j)f(i,j)f(i,j) 内。这样就是为什么再加一遍 f(i−1,j)f(i-1,j)f(i−1,j) 的原因。 如果当前 ai&gt;axa_i &gt; a_xai​&gt;ax​，f(i,j)=f(i−1,j)∗2f(i,j) = f(i-1,j)*2f(i,j)=f(i−1,j)∗2 。分为选和不选两种方案，都是 f(i−1,j)f(i-1,j)f(i−1,j) 种 。 如果当前ai&lt;axa_i&lt;a_xai​&lt;ax​ ，f(i,j)=f(i−1,j−1)+f(i−1,j)f(i,j) = f(i-1,j-1) + f(i-1,j)f(i,j)=f(i−1,j−1)+f(i−1,j) ，选的话是只需要满足前面有 j−1j-1j−1 个比他小的数。 如果当前ai=axa_i = a_xai​=ax​ ： (1)(1)(1) 如果i&gt;xi &gt;xi&gt;x ，那么将 aia_iai​ 看成比 axa_xax​ 大的数。 （2）否则将 aia_iai​ 看成比axa_xax​ 小的数。 这一步是通过字典序去重，因为如果有多个相同的数，可以取任意一个，我们不妨设定为每次取下标最小的一个，越靠后的数越大。 如果还有什么不懂的地方，看代码： Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : D.cpp @Time : 2021/07/06 10:09:22 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 5e2+10; const ll mod = 998244353; int n; ll a[N],f[N][N]; ll work()&#123; ll ans = 0ll; rep(i,1,n)&#123; if(a[i] == -1)continue; memset(f,0,sizeof f); f[0][0] = 1; rep(p,1,n)&#123; if(p == i)&#123;memcpy(f[p],f[p-1],sizeof f[p-1]); continue;&#125; rep(k,0,p)&#123; if(a[p] &gt; 0)&#123; ll c = 0;if(k-1&gt;=0)c = f[p-1][k-1]; if(a[p] &gt; a[i])f[p][k] = (f[p-1][k]*2ll)%mod; else if(a[p]&lt;a[i] or p&lt;i)f[p][k] = (c + f[p-1][k])%mod;//选的小，那么能当替死鬼 else f[p][k] = (f[p-1][k]*2ll)%mod; &#125; else &#123; f[p][k] = (f[p-1][k+1] + f[p-1][k])%mod; if(!k and p&lt;i)(f[p][k] += f[p-1][k])%mod; &#125; &#125; &#125; ll sum = 0ll; rep(j,0,n)sum = (sum + f[n][j])%mod; ans += sum * a[i]; ans %= mod; &#125; return ans; &#125; void solve()&#123; read(n); rep(i,1,n)&#123; char op[3]; scanf(&quot;%s&quot;,op); if(*op == &#x27;-&#x27;)&#123; a[i] = -1; &#125; else &#123; read(a[i]); &#125; &#125; write(work());pc(&#x27; &#x27;); &#125; signed main()&#123;solve();return 0;&#125; E1 - Abnormal Permutation Pairs (easy version) 思路：对于字典序的题目，我们可以枚举前面相同的位数来进行 dpdpdp。我们设前 x−1x-1x−1 位相同。 且设 i=n−xi = n-xi=n−x 。因为前x−1x-1x−1 位相同，所以前 x−1x-1x−1 位内部的逆序对数相同，并且前 x−1x-1x−1 位对于后 i+1i+1i+1 位来说，逆序对数也相同，那么要保证 ppp 串逆序对数大于 qqq 串，就说明是后 i+1i+1i+1 位内部逆序对数 ppp 串大于 qqq 串 。设 uuu 为 ppp 串后 iii 位内部的逆序对数， vvv 为 qqq 串后 iii 位内部的逆序对数。sss 为 ppp 串后第 iii 位对于后面 iii 位的逆序对数， ttt 为 qqq 串后第 iii 位对于后面 iii 位的逆序对数。有 u+s&gt;v+tu+s&gt;v+tu+s&gt;v+t 所以 t−s&lt;u−vt-s &lt; u-vt−s&lt;u−v ，对于每一组 u,vu,vu,v 计算符合要求的 t−st-st−s 的个数，则有 ∑x=1u−v−1i+1−x=i(i+1)2−(i+1−(u−v))(i+2−(u−v))2\\sum_{x=1}^{u-v-1} i+1-x = \\frac{i(i+1)}{2} - \\frac{(i+1-(u-v))(i+2-(u-v))}{2} x=1∑u−v−1​i+1−x=2i(i+1)​−2(i+1−(u−v))(i+2−(u−v))​ 设 f(i,u−v)=i(i+1)2−max((i+1−(u−v))(i+2−(u−v))2,0)f(i,u-v) = \\frac{i(i+1)}{2} - max(\\frac{(i+1-(u-v))(i+2-(u-v))}{2},0) f(i,u−v)=2i(i+1)​−max(2(i+1−(u−v))(i+2−(u−v))​,0) 意为对于 iii 位不同且对于 111 组 (u,v)(u,v)(u,v) 所满足的(s,t)(s,t)(s,t) 的方案数。我们设 dp(i,j)dp(i,j)dp(i,j) 代表长度为 iii 的排列中，逆序对数为 jjj 的方案数。可以通过前缀和 O(n3)O(n^3)O(n3) 计算出来。那么对于每对 (u,v)(u,v)(u,v) 满足的方案数就是 dpi,udpi,vf(i,u−v)dp_{i,u}dp_{i,v}f(i,u-v)dpi,u​dpi,v​f(i,u−v) ，那么枚举 (u,v)(u,v)(u,v) 的总方案数就是 ∑u=0i(i+1)/2∑v=0u−1dpi,udpi,vf(i,u−v)\\sum_{u=0}^{i(i+1)/2}\\sum_{v=0}^{u-1} dp_{i,u}dp_{i,v}f(i,u-v) u=0∑i(i+1)/2​v=0∑u−1​dpi,u​dpi,v​f(i,u−v) 还得再乘上前面的相同部分：在 nnn 位中选择 n−i−1n-i-1n−i−1 位的方案数 Cnn−i+1C^{n-i+1}_{n}Cnn−i+1​ ，全排列 n−i−1n-i-1n−i−1 位 (n−i−1)!(n-i-1)!(n−i−1)! 因此答案是 ∑i=0n−1Cnn−i+1(n−i−1)!∑u=0i(i+1)/2∑v=0u−1dpi,udpi,vf(i,u−v)\\sum^{n-1}_{i=0}C^{n-i+1}_{n} (n-i-1)!\\sum_{u=0}^{i(i+1)/2}\\sum_{v=0}^{u-1} dp_{i,u}dp_{i,v}f(i,u-v) i=0∑n−1​Cnn−i+1​(n−i−1)!u=0∑i(i+1)/2​v=0∑u−1​dpi,u​dpi,v​f(i,u−v) 复杂度 O(n5)O(n^5)O(n5) 考虑到 v&lt;u−iv&lt;u-iv&lt;u−i 时，f(i,u−v)=i(i+1)2f(i,u-v) = \\frac{i(i+1)}{2}f(i,u−v)=2i(i+1)​ 那么可以维护 dpi,jdp_{i,j}dpi,j​ 的前缀和结合 f(i,u−v)f(i,u-v)f(i,u−v) 达到 O(n4)O(n^4)O(n4) 参考dalao的代码 Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : E1.cpp @Time : 2021/07/06 15:40:33 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 55; #define int long long int n;ll mod,f[N][N*N]; ll C[N][N],A[N],sum[N][N*N]; void init()&#123; f[1][0] = 1ll; rep(i,0ll,N*N)sum[1][i] = 1ll; for(int i=2ll;i&lt;=n;i++)&#123; for(int j=0ll;j&lt;=i*(i-1)/2;j++)&#123; f[i][j]=sum[i-1][j]; //\tprintf(&quot;%d %d %d &quot;,i,j,f[i][j]); if(j-i&gt;=0) f[i][j]=(f[i][j]-sum[i-1][j-i]+mod)%mod; //\tprintf(&quot;%d %d %d &quot;,i,j,f[i][j]); &#125; sum[i][0]=f[i][0]; for(int j=1;j&lt;=N*N;j++) sum[i][j]=(sum[i][j-1]+f[i][j])%mod; &#125; //printf(&quot;%lld &quot;,f[10][5]); C[0][0] = 1ll; //C[1][1] = C[1][0] = 1ll; rep(i,1ll,n)&#123; rep(j,0ll,i)&#123; ll now = 0ll;if(j)now = C[i-1][j-1]; C[i][j] = (C[i-1][j] + now)%mod; //printf(&quot;%lld &quot;,C[i][j]); &#125; &#125; A[0] =1ll ; rep(i,1ll,n)A[i] = (A[i-1] * i)%mod; &#125; int a[N],b[N]; void solve()&#123; read(n);read(mod); init(); //枚举前面有几个一样的 ll ans = 0ll; rep(idx,0ll,n-1)&#123; //\tll idx = n - i;// 后面有idx+1位， //枚举u,v ll lin = idx*(idx+1)/2; ll now = 0ll; rep(u,1ll,(idx*(idx-1))/2ll)&#123; now += (lin%mod*sum[idx][u-1]%mod)%mod*f[idx][u]%mod; //printf(&quot;%lld %lld %lld &quot;,idx,u-1,sum[idx][u-1]); now %= mod; rep(v,max(0ll,u-idx),u-1)&#123; ll k = ((idx-u+v+1)*(idx-u+v+2)/2%mod*f[idx][v])%mod; now = ((now - k*f[idx][u])%mod+mod)%mod; &#125; &#125; ans += (now * C[n][n-idx-1]%mod*A[n-idx-1])%mod; ans %= mod; // printf(&quot;%lld %lld %lld &quot;,C[n][n-idx-1],A[n-idx-1],); &#125; write(ans);pc(&#x27; &#x27;); &#125; signed main()&#123; solve();return 0;&#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.ShichikujiandPowerGrid(CodeforcesRound#597(Div.2)题解)xiaodangao","path":"/2021/07/03/D. Shichikuji and Power Grid(Codeforces Round #597 (Div. 2)题解)-xiaodangao/","content":"题目链接：D. Shichikuji and Power Grid 思路：这是一个完全图，如果没有发电站的限制，只靠电线就能通电，那么很明显是一道MSTMSTMST题目，只需要用Kruscal算法求一遍MSTMSTMST就可以，不过该题目表明必须间接或直接与发电站相连，不妨就设0点为一个超级发电站，初始时除了图上边之外，还另外的将每个点都连到0点一条边，边权是C[i]C[i]C[i]，那么这样就可以满足题目的要求。建立超级原点是许多题目能用到的。 Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : ac3728.cpp @Time : 2021/07/03 10:21:35 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 4e6+10; int n,m; pair&lt;ll,pair&lt;int,int&gt; &gt;S[N]; ll c[2010],k[2010]; pair&lt;int,int&gt;a[2010]; ll dis(int x,int y)&#123; return abs(a[x].first-a[y].first) + abs(a[x].second-a[y].second); &#125; int fa[2010]; int found(int x)&#123; if(fa[x] == x)return x; return fa[x] = found(fa[x]); &#125; int id[2010]; ll mi[N]; pair&lt;int,int&gt;s[2010]; int t[2010]; void solve()&#123; read(n); rep(i,1,n)fa[i] = i,id[i] = i; int tot = 0; rep(i,1,n)&#123; read(a[i].first);read(a[i].second); &#125; rep(i,1,n)read(c[i]),mi[i] = c[i]; rep(i,1,n)read(k[i]); rep(i,1,n)&#123; rep(j,1,i-1)&#123; S[++tot] = &#123;(k[i] + k[j]) * dis(i,j),&#123;i,j&#125;&#125;; &#125; &#125; rep(i,1,n)&#123; S[++tot] = &#123;c[i],&#123;0,i&#125;&#125;; &#125; sort(S+1,S+1+tot); ll ans = 0ll; int tt = 0,cnt = 0 ; rep(i,1,tot)&#123; int q = found(S[i].second.first),p = found(S[i].second.second); ll val = S[i].first; if(q == p)continue; //val大于 if(!S[i].second.first or !S[i].second.second)&#123; t[++cnt] = max(S[i].second.first,S[i].second.second); ans += c[max(S[i].second.first,S[i].second.second)]; &#125; else &#123; s[++tt] = &#123;S[i].second.first,S[i].second.second&#125;; ans += S[i].first; &#125; fa[q] = p; &#125; //rep(i,1,n)printf(&quot;%d &quot;,id[i]);pc(&#x27; &#x27;); //write(mi[found(1)]);pc(&#x27; &#x27;); write(ans);pc(&#x27; &#x27;); printf(&quot;%d &quot;,cnt); rep(i,1,cnt)&#123; printf(&quot;%d%c&quot;,t[i],&quot; &quot;[i==cnt]); &#125;//pc(&#x27; &#x27;); printf(&quot;%d &quot;,tt); rep(i,1,tt)&#123; printf(&quot;%d %d &quot;,s[i].first,s[i].second); &#125; &#125; signed main()&#123;solve();return 0;&#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"CodeforcesRound#726(Div.2)F.FigureFixing题解xiaodangao","path":"/2021/07/03/Codeforces Round #726 (Div. 2)F. Figure Fixing题解-xiaodangao/","content":"题目链接：F. Figure Fixing 思路：首先我们发现如果∑ti−vi\\sum t_i-v_i∑ti​−vi​为奇数，那么一定NONONO,因为每次改变时是一条边两头改变，改变数总是偶数，所以奇数绝对不行，因为他问的是在进行了若干次操作之后能否可行的问题，所以我们可以通过找到最小变化量来解决该问题，这应该是个构造问题。再次分析发现如果存在奇环就一定可以。 我们随便选一张图可以发现： ***只要联通我们就可以通过若干次选择将所有点的权值集中到任意一个点上***如上图所示，我们可以通过边(F,E)(F,E)(F,E)将FFF的点权清零，然后通过(E,D)(E,D)(E,D)将EEE的点权清零，这样操作，E,F,DE,F,DE,F,D上的所有点权都集中在了DDD上，并且该操作也是可逆的。那么因为该图是联通图，第一步我们可以将所有权值以这样的形式移动到一个奇环上，接下来： 其中边权是指操作该边使该边两端节点加上某一个值，发现这样一趟下来，只有一个点点权增加了2，其余点权皆不受影响，这样一来我们就可以通过若干次这种操作将整张图清0。然后如果没有奇环，那么该图是二分图，因为二分图内部没有边连接，操作一条边的结果只可能是二分图两边增加或减少，换句话说，两边增量保持相等，所以只需要保证两边需求增量相同就一定有一种构造方法。 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb emplace_back #define mp make_pair #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e5+10; vector&lt;int&gt;G[N]; int n,m,col[N]; int _; int dis[N]; int x; bool flag ; void dfs(int x,int color)&#123; col[x] = color; for(auto p:G[x])&#123; if(col[p] == color)flag = true; if(col[p])continue; dfs(p,-color); &#125; &#125; void init()&#123;rep(i,1,n)G[i].clear(),col[i] = 0; &#125; void solve()&#123; read(_); while(_--)&#123; flag = false; read(n);read(m); rep(i,1,n)read(dis[i]); init(); ll sum = 0ll; rep(i,1,n)read(x),dis[i] = x-dis[i],sum += 1ll*dis[i]; rep(i,1,m)&#123; int u,v; read(u);read(v); G[u].pb(v);G[v].pb(u); &#125; dfs(1,1);ll ans = 0ll; rep(i,1,n)&#123; if(col[i] == 1)ans+=1ll * dis[i]; &#125; if(flag == false and ans == sum - ans)flag = true; if(sum % 2)flag = false; if(flag)puts(&quot;YES&quot;);else puts(&quot;NO&quot;); &#125; &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"CodeforcesRound#727(Div.2)题解xiaodangao","path":"/2021/07/02/Codeforces Round #727 (Div. 2)题解-xiaodangao/","content":"题目链接：Codeforces Round #727 (Div. 2) Problem.A Contest Start 思路：数学问题，看懂题目思路应该就出来了。单组复杂度Θ(1)\\Theta (1)Θ(1) Code:Code:Code: #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;vector&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i, a, b) for (int i = a; i &lt;= b; ++i) #define bep(i, a, b) for (int i = a; i &gt;= b; --i) #define lowbit(x) (x &amp; (-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template &lt;typename T&gt; void read(T&amp; x) &#123; static char c; static int f; for (c = ch(), f = 1; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c = ch()) if (c == &#x27;-&#x27;) f = -f; for (x = 0; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = ch()) x = x * 10 + (c &amp; 15); x *= f; &#125; template &lt;typename T&gt; void write(T x) &#123; static char q[65]; int cnt = 0; if (x &lt; 0) pc(&#x27;-&#x27;), x = -x; q[++cnt] = x % 10, x /= 10; while (x) q[++cnt] = x % 10, x /= 10; while (cnt) pc(q[cnt--] + &#x27;0&#x27;); &#125; const int N = 1e5 + 10; int _; ll n,x,t; void solve() &#123; read(_); while (_--) &#123; read(n);read(x);read(t); ll hh = min(t/x,n-1); // printf(&quot;%lld &quot;,hh); ll k = ceil(((n-1)*x - t)/(x*1.0)); // printf(&quot;%lld &quot;,k); k = max(k,0ll); ll ans = k * hh + (hh + 1)*hh/2; write(ans);pc(&#x27; &#x27;); &#125; &#125; signed main() &#123; solve(); return 0; &#125; Problem.B Love Song 思路：前缀和预处理一下。 Code:Code:Code: #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;vector&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i, a, b) for (int i = a; i &lt;= b; ++i) #define bep(i, a, b) for (int i = a; i &gt;= b; --i) #define lowbit(x) (x &amp; (-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template &lt;typename T&gt; void read(T&amp; x) &#123; static char c; static int f; for (c = ch(), f = 1; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c = ch()) if (c == &#x27;-&#x27;) f = -f; for (x = 0; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = ch()) x = x * 10 + (c &amp; 15); x *= f; &#125; template &lt;typename T&gt; void write(T x) &#123; static char q[65]; int cnt = 0; if (x &lt; 0) pc(&#x27;-&#x27;), x = -x; q[++cnt] = x % 10, x /= 10; while (x) q[++cnt] = x % 10, x /= 10; while (cnt) pc(q[cnt--] + &#x27;0&#x27;); &#125; const int N = 3e5 + 10; int sum[N][202]; void solve() &#123; int ns, q; ios::sync_with_stdio(false); cin &gt;&gt; ns &gt;&gt; q; string s;cin &gt;&gt; s; s = &#x27;0&#x27; + s; rep(i,1,ns) &#123; for (char c = &#x27;a&#x27;; c &lt;= &#x27;z&#x27; ; c ++) &#123; sum[i][c] = sum[i-1][c]; if (s[i] == c)sum[i][c]++; &#125; &#125; while (q--) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; ll t = 0; for (int i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; i ++) &#123; t += (sum[r][i] - sum[l-1][i]) * (i-&#x27;a&#x27;+ 1); &#125; cout &lt;&lt; t &lt;&lt; endl; &#125; &#125; signed main()&#123;solve();return 0; &#125; Problem.C Stable Groups 思路：贪心，模拟，具体实现看代码。 Code:Code:Code: #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;vector&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i, a, b) for (int i = a; i &lt;= b; ++i) #define bep(i, a, b) for (int i = a; i &gt;= b; --i) #define lowbit(x) (x &amp; (-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template &lt;typename T&gt; void read(T&amp; x) &#123; static char c; static int f; for (c = ch(), f = 1; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c = ch()) if (c == &#x27;-&#x27;) f = -f; for (x = 0; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = ch()) x = x * 10 + (c &amp; 15); x *= f; &#125; template &lt;typename T&gt; void write(T x) &#123; static char q[65]; int cnt = 0; if (x &lt; 0) pc(&#x27;-&#x27;), x = -x; q[++cnt] = x % 10, x /= 10; while (x) q[++cnt] = x % 10, x /= 10; while (cnt) pc(q[cnt--] + &#x27;0&#x27;); &#125; const int N = 200000 + 99; ll a[N]; struct sk &#123; ll fi, se; bool operator&lt;(sk rhs) const&#123; return rhs.fi &lt; fi; &#125; &#125;; priority_queue&lt;sk&gt;qq; bool ff[N]; void solve() &#123; ll n, k , x; read(n);read(k);read(x); ll m = k; for (ll i = 1; i &lt;= n; i ++) &#123; read(a[i]); &#125; sort(a + 1, a + 1 + n); ll ans = 1; for (ll i = 1; i &lt; n; i ++) &#123; if (a[i] + x &gt;= a[i + 1])continue; ans++; ll se = i; ll tr; ll len = a[i + 1] - a[i]; len -= x; len = len / x + (len%x != 0); qq.push(&#123;len, se&#125;); &#125; while (!qq.empty()) &#123; auto now = qq.top(); qq.pop(); if (m &gt;= now.fi) &#123; ans--; m -= now.fi; &#125; &#125; write(ans);pc(&#x27; &#x27;); &#125; signed main() &#123; solve(); return 0; &#125; Problem.D PriceFixed 思路：对于每一种商品，都给了他半价时的要求，所以我们将这个要求进行排序，然后贪心，优先实现要求苛刻的，因为每一种商品都有购买数量，所以我们不可能购买多于该购买数量的。其次，我们排完序后，定义一个指针，这个指针一开始指向购买的最后一件商品，这是上限，下限是当前的半价条件和购买的件数，（我们此次计算只计算最多半价件数，最后用 ∑a[i]\\sum a[i]∑a[i]减去最多半价件数就是最小原价购买的数量），如果购买的件数还没达到下限（半价条件），换句话说，当前商品全部能够半价，那么上限移至当前上限-购买件数，否则我们根据下限：半价条件来计算最大半价购买数量，同时上限指针移动。 Code:Code:Code: #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;vector&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i, a, b) for (int i = a; i &lt;= b; ++i) #define bep(i, a, b) for (int i = a; i &gt;= b; --i) #define lowbit(x) (x &amp; (-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template &lt;typename T&gt; void read(T&amp; x) &#123; static char c; static int f; for (c = ch(), f = 1; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c = ch()) if (c == &#x27;-&#x27;) f = -f; for (x = 0; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = ch()) x = x * 10 + (c &amp; 15); x *= f; &#125; template &lt;typename T&gt; void write(T x) &#123; static char q[65]; int cnt = 0; if (x &lt; 0) pc(&#x27;-&#x27;), x = -x; q[++cnt] = x % 10, x /= 10; while (x) q[++cnt] = x % 10, x /= 10; while (cnt) pc(q[cnt--] + &#x27;0&#x27;); &#125; const int N = 2e5 + 10; int _; int n,x,t; pair&lt;ll,ll&gt;a[N]; void solve() &#123; // read(_); read(n); ll sum = 0; rep(i,1,n)&#123; ll u,v; read(u);read(v); a[i] = &#123;v+1,u&#125;; sum += u; &#125; sort(a+1,a+1+n);reverse(a+1,a+1+n); ll now = sum,ans = 0ll; rep(i,1,n)&#123; //puts(&quot;x&quot;); if(a[i].first &gt; sum)continue; ll dis = now - a[i].first + 1;//最多个数 ll suf = a[i].second; if(suf &gt;= dis)&#123; now = a[i].first - 1; ans += dis; &#125; else &#123; now -= suf; ans += suf; &#125; &#125; ll k =( sum - ans )*2; ans += k; write(ans);pc(&#x27; &#x27;); // &#125; &#125; signed main() &#123; solve(); return 0; &#125; Problem.E Game with Cards 输入：第一行n,mn,mn,m; 接下来nnn组每一组输入一个a[i]a[i]a[i]，然后两个范围x[i][j],(pair,j∈[0,1])x[i][j],(pair,j∈[0,1])x[i][j],(pair,j∈[0,1]) 思路：考虑DP，朴素做法是维护 f(0/1,i,j)f(0/1,i,j)f(0/1,i,j) 其中第一维代表的是当前更新左右手，第二维代表当前进行到第 iii 个，第三维代表另一只手所在位置，其实这就是一个典型的线性DP，我们通过三维能够确定两只手的全部位置信息 ,f(k,i,j)f(k,i,j)f(k,i,j) 为真当且仅当f(k,i−1,j)f(k,i-1,j)f(k,i−1,j)为真且x[i][k].l≤a[i]≤x[i][k].rx[i][k].l \\leq a[i] \\leq x[i][k].rx[i][k].l≤a[i]≤x[i][k].r且x[i][k⨁1].l≤a[j]≤x[i][k⨁1].rx[i][k \\bigoplus 1].l \\leq a[j] \\leq x[i][k \\bigoplus 1].rx[i][k⨁1].l≤a[j]≤x[i][k⨁1].r。时间复杂度和空间复杂度均为Θ(n2)\\Theta (n^2)Θ(n2)。发现该fff数组存储的是是否可达，因此可以利用一个setsetset进行维护，这个操作就有点类似于离散化的操作，存储目前所有可达下标，再优化一些，我们发现我们每一次都更新该setsetset因此我们可以反复利用一个setsetset来减少一维(i)，然后每一次更新时，我们只需要在满足x[i][k].l≤a[i]≤x[i][k].rx[i][k].l \\leq a[i] \\leq x[i][k].rx[i][k].l≤a[i]≤x[i][k].r时，遍历 setsetset 集合，因为 setsetset 集合有序，所以满足单调性，在第一个符合条件 x[i][k⨁1].l≤a[j]≤x[i][k⨁1].rx[i][k \\bigoplus 1].l \\leq a[j] \\leq x[i][k \\bigoplus 1].rx[i][k⨁1].l≤a[j]≤x[i][k⨁1].r 之后就可以退出。时间复杂度 Θ(nlogn)\\Theta (nlogn)Θ(nlogn)，然后每次记录一下路径就可以了。 Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : E.cpp @Time : 2021/07/01 14:49:05 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e5+10; int a[N]; pair&lt;int,int&gt;x[N][2]; int n,m; set&lt;pair&lt;int,int&gt; &gt;f[2]; int to[N][2]; void print(int idx,int x)&#123; if(!idx)return ; print(to[idx][x],x^1); rep(i,to[idx][x]+1,idx)write(x),pc(&#x27; &#x27;); &#125; void solve()&#123; read(n);read(m); rep(i,1,n)&#123; read(a[i]); rep(j,0,1)read(x[i][j].first),read(x[i][j].second); &#125; if(x[1][0].first &lt;= a[1] and a[1]&lt;=x[1][0].second and !x[1][1].first)f[0].insert(&#123;0,0&#125;); if(x[1][1].first &lt;= a[1] and a[1]&lt;=x[1][1].second and !x[1][0].first)f[1].insert(&#123;0,0&#125;); rep(i,2,n)&#123; bool x1 = f[1].empty(),x0 = f[0].empty(); if(!x1)&#123;f[0].insert(&#123;a[i-1],i-1&#125;); &#125; if(!x0)&#123;f[1].insert(&#123;a[i-1],i-1&#125;); &#125; rep(j,0,1)&#123; if(x[i][j].first&lt;=a[i] and a[i]&lt;=x[i][j].second)&#123; while(f[j].size() and (*f[j].begin()).first&lt;x[i][j^1].first)&#123;f[j].erase(f[j].begin()); &#125; while(f[j].size() and (*f[j].rbegin()).first&gt;x[i][j^1].second)&#123;f[j].erase(*f[j].rbegin()); &#125; &#125;else f[j].clear(); if(!f[j].empty())to[i][j] = (*f[j].begin()).second; &#125; &#125; if(!f[0].empty())puts(&quot;Yes&quot;),print(n,0); else if(!f[1].empty())puts(&quot;Yes&quot;),print(n,1); else puts(&quot;No&quot;); &#125; signed main()&#123;solve();return 0; &#125; Problem.F Strange Array 这个题意有点难理解； 思路：该题需要求中位数，因此我们想到对于每一次询问，首先考虑该值比中值要小，我们将小于等于该数的设为-1，相应的将大于该数的设为1，于是这样就将题意转化为求1≤l≤i≤r≤n1 \\leq l \\leq i \\leq r \\leq n1≤l≤i≤r≤n的范围里，最大的和，因为该题要求的距离=（大于a[i]的个数-小于等于a[i]的个数）/2 ,所以可以这样转化，通过转化我们发现问题好像简化了一点点，但是如果每一次都进行赋值1，-1的话，复杂度过不去，问题就是每一次进行赋值的操作，对于求区间最大值，我们可以通过维护一个线段树来进行求解，具体做法是：首先进行维护数组前缀和，然后对于前缀和建立线段树，维护最大值，最小值，然后将区间最大值转化为询问 [i,n][i,n][i,n] 中的最大值-询问 1 i−11~i-11 i−1 中的最小值。解决了区间最大值问题之后，我们考虑优化赋值问题，我们可以通过对于数组进行排序操作来解决，遍历排序之后的数组，因为排序之后每一次移动，只需要更改当前指向的值为-1，其它值并不用动，因为我们维护的是前缀和，所以该操作对应的应为线段树区间修改，利用懒惰节点可以Θ(logn)\\Theta (logn)Θ(logn)的实现修改操作。到这里，问题就解决了，该值比中值大的情况反过来就可以。然后需要再注意一些细节。 Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : F.cpp @Time : 2021/07/02 08:32:34 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e5+10; int mi; struct T&#123; int l,r,Max,Min,tag; &#125;tr[N&lt;&lt;2]; //注意我们是在原未排序数组中建树维护前缀和 void buildL(int l,int r,int p)&#123; int mid = l + r &gt;&gt; 1; if(l == r)&#123; tr[p] = &#123;l,r,l,l,0&#125;;return ; &#125; buildL(l,mid,p&lt;&lt;1);buildL(mid+1,r,p&lt;&lt;1|1); tr[p] = &#123;l,r,max(tr[p&lt;&lt;1].Max , tr[p&lt;&lt;1|1].Max),min(tr[p&lt;&lt;1].Min , tr[p&lt;&lt;1|1].Min),0&#125;; &#125; void down(int p)&#123; if(!tr[p].tag)return ; tr[p&lt;&lt;1].Max += tr[p].tag,tr[p&lt;&lt;1|1].Max += tr[p].tag; tr[p&lt;&lt;1].Min += tr[p].tag,tr[p&lt;&lt;1|1].Min += tr[p].tag; tr[p&lt;&lt;1].tag += tr[p].tag,tr[p&lt;&lt;1|1].tag += tr[p].tag; tr[p].tag = 0;return; &#125; int queryMax(int s,int t,int p)&#123; if(tr[p].l &gt; t or tr[p].r &lt; s)return -1e8; if(s &lt;= tr[p].l and tr[p].r&lt;= t)&#123;return tr[p].Max; &#125; down(p); return max(queryMax(s,t,p&lt;&lt;1),queryMax(s,t,p&lt;&lt;1|1)); &#125; int queryMin(int s,int t,int p)&#123; if(tr[p].l &gt; t or tr[p].r &lt; s)return 1e8; if(s &lt;= tr[p].l and tr[p].r&lt;= t)&#123;return tr[p].Min; &#125; down(p); return min(queryMin(s,t,p&lt;&lt;1),queryMin(s,t,p&lt;&lt;1|1)); &#125; void modify(int s,int t,int p,int k)&#123; if(tr[p].l &gt; t or tr[p].r &lt; s)return ; if(s &lt;= tr[p].l and tr[p].r &lt;= t)&#123;tr[p].Max+=k;tr[p].Min+=k;tr[p].tag += k;return ; &#125; down(p); modify(s,t,p&lt;&lt;1,k);modify(s,t,p&lt;&lt;1|1,k); tr[p].Max = max(tr[p&lt;&lt;1].Max,tr[p&lt;&lt;1|1].Max); tr[p].Min = min(tr[p&lt;&lt;1].Min,tr[p&lt;&lt;1|1].Min); &#125; struct nodex&#123; int a,id; bool operator&lt;(const nodex &amp;x)&#123; return x.a&gt;a; &#125; &#125;a[N]; int n; int ans[N]; void work(int idx,int idy)&#123; if(idx&gt;idy)swap(idx,idy); rep(i,idx,idy)&#123; modify(a[i].id,n,1,-2); &#125; &#125; void print()&#123;rep(i,1,n)printf(&quot;%d &quot;,ans[i]); &#125; int nxt[N]; void init()&#123; bep(i,n,1)&#123; int idx = i; while(a[i].a == a[i-1].a)i--; nxt[idx] = i; &#125; &#125; void solve()&#123; read(n); mi = n+1; rep(i,1,n)read(a[i].a),a[i].id = i,mi = min(a[i].a,mi); buildL(1,n,1); sort(a+1,a+1+n); init(); rep(i,1,n)&#123; int idx = i; while(i+1 &lt;= n and a[i].a == a[i+1].a)&#123; auto a1 = queryMin(1,a[i].id-1,1); auto a2 = queryMax(a[i].id,n,1); a1 = min(0,a1); if(a[i].id == 1)a1 = 0; ans[a[i].id] = (a2 - a1)/2;i++; &#125; auto a1 = queryMin(1,a[i].id-1,1),a2 = queryMax(a[i].id,n,1); a1 = min(0,a1); if(a[i].id == 1)a1 = 0; ans[a[i].id] = (a2-a1)/2; work(idx,i); &#125; // rep(i,1,n)&#123; // printf(&quot;%d &quot;,ans[i]); // &#125; //memset(tr,0,sizeof tr); buildL(1,n,1); bep(i,n,1)&#123; int idx = i; int idy = nxt[idx]; idy = max(1,idy); bep(j,idx,idy)&#123; auto a1 = queryMax(a[j].id,n,1); auto a2 = queryMin(1,a[j].id-1,1); a2 = min(0,a2); if(a[j].id == 1)ans[1] = max(ans[1],(a1+1)/2-1); else ans[a[j].id] = max(ans[a[j].id],(a1-a2+1)/2-1); &#125; work(idx,idy); i = idy; &#125; print(); &#125; signed main()&#123;solve();return 0; &#125; 写在最后 F题我一开始想的区间最大值操作并不是维护前缀和，这样明显是不对的，因为有负值的存在，即该区间可能并不是真正最大值，可能他的子区间的子区间存在一个小于0的极小值，一个大于0的极大值。因此，这种操作不能正确的求出区间最大值。","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"拉格朗日插值模板（P4781）xiaodangao","path":"/2021/06/28/拉格朗日插值模板（P4781）-xiaodangao/","content":"题目链接：拉格朗日插值 拉格朗日插值：给定 k+1k+1k+1 个点对 (xi,yi)(x_i,y_i)(xi​,yi​) (xix_ixi​各不相同)能够唯一确定一个最高次为 kkk 次的多项式，那么如何进行构造，来求该多项式呢？我们先以经过 (x1,1),(x2,0),(x3,0)(x_1,1),(x_2,0),(x_3,0)(x1​,1),(x2​,0),(x3​,0) 这三个点的4次多项式为例：那么我们可以进行构造设 f(X)=(X−x2)∗(X−x3)(x1−x2)∗(x1−x3)f(X)=\\frac{(X-x_2)*(X-x_3)}{(x_1-x_2)*(x_1-x_3)}f(X)=(x1​−x2​)∗(x1​−x3​)(X−x2​)∗(X−x3​)​，我们带入这三个点发现显然该多项式是我们所求的多项式。那么如果我们将该三个点扩展到 (x1,y1),(x2,y2),(x3,y3)(x_1,y_1),(x_2,y_2),(x_3,y_3)(x1​,y1​),(x2​,y2​),(x3​,y3​) 呢？ 显然： f1(X)=(X−x2)∗(X−x3)(x1−x2)∗(x1−x3)∗y1f_1(X)=\\frac{(X-x_2)*(X-x_3)}{(x_1-x_2)*(x_1-x_3)}*y_1f1​(X)=(x1​−x2​)∗(x1​−x3​)(X−x2​)∗(X−x3​)​∗y1​经过(x1,y1)(x_1,y_1)(x1​,y1​)，且f1(x2)=0,f1(x3)=0f_1(x_2) = 0,f_1(x_3) = 0f1​(x2​)=0,f1​(x3​)=0 f2(X)=(X−x1)∗(X−x3)(x2−x1)∗(x2−x3)∗y2f_2(X)=\\frac{(X-x_1)*(X-x_3)}{(x_2-x_1)*(x_2-x_3)}*y_2f2​(X)=(x2​−x1​)∗(x2​−x3​)(X−x1​)∗(X−x3​)​∗y2​经过(x2,y2)(x_2,y_2)(x2​,y2​)，且f2(x1)=0,f2(x3)=0f_2(x_1) = 0,f_2(x_3) = 0f2​(x1​)=0,f2​(x3​)=0 f3(X)=(X−x1)∗(X−x2)(x3−x1)∗(x3−x2)∗y3f_3(X)=\\frac{(X-x_1)*(X-x_2)}{(x_3-x_1)*(x_3-x_2)}*y_3f3​(X)=(x3​−x1​)∗(x3​−x2​)(X−x1​)∗(X−x2​)​∗y3​经过(x3,y3)(x_3,y_3)(x3​,y3​)，且f3(x1)=0,f3(x2)=0f_3(x_1) = 0,f_3(x_2) = 0f3​(x1​)=0,f3​(x2​)=0 所以我们最后构造的多项式为F(X)=f1(X)+f2(X)+f3(X)F(X) = f_1(X) + f_2(X) + f_3(X)F(X)=f1​(X)+f2​(X)+f3​(X) 所以扩展到 nnn 项即F(X)=∑i=1i=nfi(X)F(X) = \\sum_{i=1}^{i=n}f_i(X)F(X)=∑i=1i=n​fi​(X) 这样就完成了拉格朗日插值；模板： Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : 拉格朗日模板.cpp @Time : 2021/06/28 11:21:28 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e3+10; const ll mod = 998244353; int n;ll k; ll x[N],y[N]; ll qpow(ll a,ll b)&#123; ll res = 1ll; while(b)&#123; if(b&amp;1)&#123; res *= a;res%=mod; &#125; b&gt;&gt;=1; a*=a;a%=mod; &#125; return res%mod; &#125; ll inv(ll x)&#123; return qpow(x,mod-2); &#125; void solve()&#123; read(n);read(k); rep(i,1,n)read(x[i]),read(y[i]); ll ans = 0ll; rep(i,1,n)&#123; ll res = y[i]; rep(j,1,n)&#123; if(i == j)continue; res *= (k-x[j]); res %= mod; res *= inv(x[i] - x[j]); res %= mod; &#125; ans += (res%mod + mod)%mod; ans %= mod; &#125; write(ans);pc(&#x27; &#x27;); &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"GorgeousSequence（吉老师线段树）xiaodangao","path":"/2021/06/16/Gorgeous Sequence（吉老师线段树）-xiaodangao/","content":"题目链接：Gorgeous Sequence 思路：本题用普通线段树完成不了将区间内的大于k的数都等于k的操作，但吉老师线段树可以。我们需要维护的东西有：最大值，次大值，最大值的数量，区间和。对于每一次modifymodifymodify操作，我们分类讨论（为了讨论方便，我们将当前修改的值设为k，当前区间最大值设为ma，当前次大值设为se，当前最大值数量设为cnt）： 1.ma≤kma \\leq kma≤k这时候我们不需要修改当前最大值。 2.se&lt;k&lt;mase &lt; k &lt; mase&lt;k&lt;ma这时候我们需要将当前最大值修改为k并且更新区间和。 3.k≤sek \\leq sek≤se这时候该区间我们无法进行处理，须向下更新子节点。 然后再说细节，在碰到第2类情况时，修改当前最大值就相当于修改懒标记，因为我们下传懒标记的过程就是判断儿子节点的最大值是否大于父亲节点最大值，如果大于，那么修改一下儿子节点最大值。（父亲节点都懒标记了，那么儿子节点就一定不会出现情况3） （如果第一次写，发现代码会很啰嗦 Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : HDU5306.cpp @Time : 2021/06/16 16:36:35 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e6+10; int a[N],n,m,_; struct node&#123; int l,r,ma,se,cnt; ll sum; &#125;tr[N&lt;&lt;2]; inline void up(int x)&#123; tr[x].sum = tr[x&lt;&lt;1].sum + tr[x&lt;&lt;1|1].sum; tr[x].ma = max(tr[x&lt;&lt;1].ma,tr[x&lt;&lt;1|1].ma); if(tr[x&lt;&lt;1].ma == tr[x&lt;&lt;1|1].ma)&#123; tr[x].cnt = tr[x&lt;&lt;1].cnt + tr[x&lt;&lt;1|1].cnt; tr[x].se = max(tr[x&lt;&lt;1].se,tr[x&lt;&lt;1|1].se); &#125; else if (tr[x&lt;&lt;1].ma &gt; tr[x&lt;&lt;1|1].ma) tr[x].cnt = tr[x&lt;&lt;1].cnt,tr[x].se = max(tr[x&lt;&lt;1].se,tr[x&lt;&lt;1|1].ma); else tr[x].cnt = tr[x&lt;&lt;1|1].cnt,tr[x].se = max(tr[x&lt;&lt;1|1].se,tr[x&lt;&lt;1].ma); &#125; inline void down(int p)&#123; if(tr[p].l == tr[p].r) return ; if(tr[p&lt;&lt;1].ma &gt; tr[p].ma)&#123; tr[p&lt;&lt;1].sum -= 1ll*(tr[p&lt;&lt;1].ma - tr[p].ma)*tr[p&lt;&lt;1].cnt; tr[p&lt;&lt;1].ma = tr[p].ma; &#125; if(tr[p&lt;&lt;1|1].ma &gt; tr[p].ma)&#123; tr[p&lt;&lt;1|1].sum -= 1ll*(tr[p&lt;&lt;1|1].ma - tr[p].ma)*tr[p&lt;&lt;1|1].cnt; tr[p&lt;&lt;1|1].ma = tr[p].ma; &#125; &#125; void modify(int l,int r,int p,int k)&#123; if(tr[p].ma &lt;= k)return; int mid = tr[p].l + tr[p].r &gt;&gt; 1; down(p); if(l&lt;=tr[p].l and tr[p].r&lt;=r)&#123; if(tr[p].ma&gt; k and tr[p].se &lt; k)&#123; tr[p].sum -= 1ll*(tr[p].ma-k)*tr[p].cnt; tr[p].ma = k; return ; &#125;else &#123; modify(l,r,p&lt;&lt;1,k); modify(l,r,p&lt;&lt;1|1,k); //up(p); &#125; &#125; else &#123; if(l&lt;=mid)modify(l,r,p&lt;&lt;1,k); if(r&gt;mid)modify(l,r,p&lt;&lt;1|1,k); &#125; up(p); &#125; int query1(int l,int r,int p)&#123; int mid = tr[p].l + tr[p].r &gt;&gt; 1; if(tr[p].l &gt;= l and tr[p].r &lt;= r)return tr[p].ma; int ans = -1;down(p); if(mid &gt;= l)ans = max(ans,query1(l,r,p&lt;&lt;1)); if(r &gt; mid)ans = max(ans,query1(l,r,p&lt;&lt;1|1)); //up(p); return ans ; &#125; ll query2(int l,int r,int p)&#123; int mid = tr[p].l + tr[p].r &gt;&gt; 1; if(l&lt;=tr[p].l and tr[p].r &lt;= r)return tr[p].sum; ll ans = 0;down(p); if(mid &gt;= l)ans = query2(l,r,p&lt;&lt;1); if(r &gt; mid) ans += query2(l,r,p&lt;&lt;1|1); //up(p); return ans; &#125; void build(int l,int r,int p)&#123; int mid = l + r&gt;&gt;1; if(l == r)&#123; tr[p] = &#123;l,l,a[l],-1,1,a[l]*1ll&#125;; return ; &#125; build(l,mid,p&lt;&lt;1); build(mid+1,r,p&lt;&lt;1|1); tr[p] = &#123;l,r&#125;; up(p); &#125; inline void solve()&#123; read(_); while(_--)&#123; read(n);read(m); rep(i,1,n)&#123; read(a[i]); &#125; build(1,n,1); while(m--)&#123; int x,y,t,op; read(op); if(op == 0)&#123; read(x);read(y);read(t); modify(x,y,1,t); continue; &#125;else if(op == 1)&#123; read(x);read(y); write(query1(x,y,1)); &#125;else &#123; read(x);read(y); write(query2(x,y,1)); &#125; pc(&#x27; &#x27;); &#125; &#125; &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"I.MonitoringSkiPaths(题解)xiaodangao","path":"/2021/06/16/I.Monitoring Ski Paths (题解)-xiaodangao/","content":"题目链接:I.Monitoring Ski Paths 思路:标记所有起点,有一个很明显的贪心就是从下往上找,碰到第一个标记的起点,就将其标记,但是这样会出现一个问题: 会发现如果先遍历5这个节点,会导致4被标记,然后答案就错了.这是因为6 - 7 4 - 8这两条边被6给标记后,4这个节点就没用了,所以我们优化我们的贪心,即:将所有边通过起点出现的深度进行排序,优先遍历深度深的起点所连接的终点,遍历之后,将所有该终点所连接的起点取消标记.因为是棵树,所以我们遍历时可以通过并查集的方式,因为这中间可能有很多空点,所以利用并查集可以优化遍历找起点的时间. Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb emplace_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 3e5+10; int n,k,m,v,u,depth[N]; vector&lt;int&gt;p,G[N],h[N]; pair&lt;int,int&gt;a[N]; int fa[N]; bool ok[N],vis[N]; int st[N]; int found(int x)&#123; if(ok[x] == true or st[x] &gt; 0 or fa[x] == -1)return x; else return fa[x] = found(fa[x]); &#125; map&lt;pair&lt;int,int&gt;,bool&gt;S; void init(int x)&#123; for(auto s:h[x])&#123; depth[s] = depth[x] + 1; init(s); &#125; return ; &#125; int cmp(pair&lt;int,int&gt;a, pair&lt;int,int&gt;b)&#123; return depth[a.first]&gt;depth[b.first]; &#125; void solve()&#123; memset(fa,-1,sizeof fa); read(n);read(k);read(m); rep(i,1,k)&#123; read(u);read(v); fa[v] = u; h[u].pb(v); &#125; rep(i,1,n)if(fa[i] == -1)init(i); rep(i,1,m)&#123; read(u);read(v); st[u]++; G[v].pb(u); a[i] = &#123;u,v&#125;; &#125; sort(a+1,a+1+m,cmp);int cnt = 0; rep(i,1,m)&#123; int now = found(a[i].second); if(vis[a[i].second])continue; vis[a[i].second] = true; for(auto s:G[a[i].second])st[s]--; if(ok[now])continue; //printf(&quot;%d %d &quot;,a[i].first,a[i].second); //printf(&quot;%d &quot;,now); //printf(&quot;%d %d &quot;,a[i].first,a[i].second); cnt++;ok[now] = true; &#125; write(cnt);pc(&#x27; &#x27;); &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"FaceTheRightWay(POJ3276开关问题)xiaodangao","path":"/2021/06/03/Face The Right Way(POJ 3276 开关问题)-xiaodangao/","content":"题目链接：Face The Right Way 思路：枚举区间长度，我们选择从左往右处理，利用前缀和的思想，前缀和代表的是当前左指针指向的牛改变过多少次朝向，每一次满足左指针指向的牛，让他朝前方，然后如果当前牛朝后，那么我们就增加一次操作数，记住左指针从1到n，每一次满足左指针牛的要求，将差分数组中右指针指向的-1（这代表从区间[l,r]增加一次操作数量），然后每一次左右指针后移，最后到右指针指向n+1，停止，并检查后面的牛是否全部朝前。复杂度Θ(n2)\\Theta (n^2)Θ(n2) Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : 255.cpp @Time : 2021/05/31 21:05:02 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb emplace_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 5e3+10; int n; char op[N][2]; int base[N],x[N]; void solve()&#123; read(n); rep(i,1,n)&#123;scanf(&quot;%s&quot;,op[i]);if(*op[i] == &#x27;B&#x27;)base[i] = 1;&#125; int sum = 0,id = -1,ans = 99999999; rep(i,1,n)&#123; memset(x,0,sizeof x); int cnt = 0;sum = 0; rep(idx,1,n)&#123; int idy = idx + i ; sum += x[idx]; if((sum + base[idx])%2)&#123; sum++; cnt++; if(idy&lt;=n)x[idy]--; &#125; if(idy == n+1)break; // printf(&quot;%d %d &quot;,sum,base[idx]); &#125; bool flag = true; rep(j,n-i+2,n)&#123; sum += x[j]; if((sum + base[j])%2)&#123;flag = false;break; &#125; &#125; if(!flag)continue; if(ans&gt;cnt)ans = cnt,id = i; &#125; if(id == -1)&#123; puts(&quot;-1&quot;); &#125; else printf(&quot;%d %d &quot;,id,ans); &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.Armchairs(EducationalCodeforcesRound109(RatedforDiv.2)题解)xiaodangao","path":"/2021/06/03/D. Armchairs(Educational Codeforces Round 109 (Rated for Div. 2)题解)-xiaodangao/","content":"题目链接：D. Armchairs 思路：我们将0的位置放在一个数组中，将1位置放在一个数组中，我们规定每一个1位置都是有序的，即顺序不可以被改变，f(i,j)f(i,j)f(i,j)表示处理完前i个人，且第i个人坐在第j个板凳上的最小花费，显然f(i,j)=minp=i−1p=j−1f(i−1,p)+dis(a[i],a[j])f(i,j) = min_{p=i-1}^{p=j-1}f(i-1,p) + dis(a[i],a[j])f(i,j)=minp=i−1p=j−1​f(i−1,p)+dis(a[i],a[j])然后可以写出Θ(n3)\\Theta(n^3)Θ(n3)的动态规划，发现minp=i−1p=j−1f(i−1,p)min_{p=i-1}^{p=j-1}f(i-1,p)minp=i−1p=j−1​f(i−1,p)可以通过处理前缀取minminmin。Θ(1)\\Theta(1)Θ(1)求解，所以降为Θ(n2)\\Theta(n^2)Θ(n2) Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : 255.cpp @Time : 2021/05/31 21:05:02 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb emplace_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 5e3+10; int n,a[N]; int f[N][N]; int b[N],c[N],totb ,totc; int d[N][N]; void solve()&#123; read(n); memset(f,0x3f,sizeof f); rep(i,1,n)read(a[i]); rep(i,1,n)&#123; if(a[i] == 1)b[++totb] = i; else c[++totc] = i; &#125; f[0][0] = 0; rep(i,1,totb)&#123; rep(j,i,totc-totb+i)&#123; f[i][j] = d[i-1][j-1] + abs(b[i]-c[j]); if(j == i)d[i][j] = f[i][j]; else d[i][j] = min(f[i][j],d[i][j-1]); // rep(p,0,j-1)f[i][j] = min(f[i][j],f[i-1][p]+abs(b[i]-c[j])); &#125; &#125; int ans = 9999999; if(totb == 0)ans = 0; rep(i,totb,totc)ans = min(ans,f[totb][i]); write(ans); &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"M.StoneGames（ICPC2020昆明题解）xiaodangao","path":"/2021/06/02/M.Stone Games（ICPC2020昆明题解）-xiaodangao/","content":"题目链接：M.Stone Games 思路： 先上图： 所以假设当前满足[1,x][1,x][1,x]全覆盖，且[1,x][1,x][1,x]中所有元素都已经选完，那么我们发现，我们判断x+2x+2x+2是否存在没有什么意义，只有判断[1,x+1][1,x+1][1,x+1]中元素存在才有意义，选择x+1x+1x+1就是为了能构成上述图中情况1。因为有一个x+1x+1x+1，那么整体集合就可以+(x+1)+(x+1)+(x+1)，所以有几个x+1，整体集合就会增加几个x+1，最终能够停在的地方就是对于值域在[1,x+1][1,x+1][1,x+1]的所有数的sumsumsum，就是根据上图中的条件进行递推，每一次递推能够增加到∑1x+1∑i\\sum_1^{x+1}{\\sum{i}}∑1x+1​∑i。最后判断一下是否需要继续递推就可以。方法是利用可持久化权值线段树，记录区间sum值。复杂度Θ(nlogn2)\\Theta (nlogn^2)Θ(nlogn2)(咱也不知道为什么，离散化会MLE Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : 255.cpp @Time : 2021/05/31 21:05:02 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb emplace_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e6+10; const int inf = 1e9+10; int n,q; int root[N]; struct node&#123; int l,r; ll sum; &#125;tr[N*50]; int a[N]; int idx; int add(int l,int r,int p,int k)&#123; int q = ++idx; tr[q] = tr[p]; if(l == r)&#123;tr[q].sum += k;return q; &#125; int mid = l + r &gt;&gt; 1; if(k &lt;= mid)&#123;tr[q].l = add(l,mid,tr[p].l,k); &#125; else tr[q].r = add(mid+1,r,tr[p].r,k); tr[q].sum = tr[tr[q].l].sum + tr[tr[q].r].sum; return q; &#125; ll query(int l,int r,int s,int t,int p,int q)&#123; if(s&lt;=l and r&lt;=t)return tr[q].sum - tr[p].sum; int mid = l + r &gt;&gt; 1; ll ans = 0; if(s&lt;=mid)ans += query(l,mid,s,t,tr[p].l,tr[q].l); if(t&gt;mid)ans += query(mid+1,r,s,t,tr[p].r,tr[q].r); return ans; &#125; void solve()&#123; read(n);read(q); rep(i,1,n)read(a[i]);//nums.pb(a[i]); &#125; //sort(nums.begin(),nums.end()); //nums.erase(unique(nums.begin(),nums.end()),nums.end()); //int mx = *max_element(nums.begin(),nums.end()); rep(i,1,n)&#123; root[i] = add(1,inf,root[i-1],a[i]); &#125; ll ans = 0; //printf(&quot;%lld &quot;,query(0,(int)nums.size()-1,0,found(4),root[1],root[4])); while(q--)&#123; int u,v; read(u);read(v); u = (ans + u) % n+1; v = (ans + v) % n+1; if(u&gt;v)swap(u,v); // printf(&quot;%d %d &quot;,u,v); ll sum = 0; while(true)&#123; ll now = query(1,inf,1,min((ll)inf,sum+1),root[u-1],root[v]); //printf(&quot;%lld %lld &quot;,now,sum); if(now == sum)break; sum = now; &#125; ans = sum + 1; write(ans);pc(&#x27; &#x27;); &#125; &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.CutandStick(CodeforcesRound#716(Div.2)题解)xiaodangao","path":"/2021/06/02/D. Cut and Stick(Codeforces Round #716 (Div. 2)题解)-xiaodangao/","content":"题目链接：D. Cut and Stick 思路：询问最少需要分成几个区间，如果该区间众数小于等于⌈len2⌉\\lceil \\frac{len}{2} \\rceil⌈2len​⌉，那么显然答案是1。否则的话，我们需要尽可能的满足众数的要求，将尽可能多的众数放在一个区间里面，所以一个区间里面最多能够放的个数是其他数的个数+1，其余的众数就分成长度为1的区间。需要注意的是，如果我们得到的众数答案小于等于⌈len2⌉\\lceil \\frac{len}{2} \\rceil⌈2len​⌉，那么有可能我们取得的不是真正的众数，但也无伤大雅。具体做法就是利用主席树进行维护。 Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : 255.cpp @Time : 2021/05/31 21:05:02 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb emplace_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 3e5+10; int n,q; int root[N]; int a[N]; int idx ; struct node&#123; int l,r,cnt; &#125;tr[N*20]; int add(int l,int r,int p,int k)&#123; int mid = l + r &gt;&gt; 1; int q = ++idx; tr[q] = tr[p]; if(l == r)&#123;tr[q].cnt++;return q; &#125; if(k&lt;=mid)tr[q].l = add(l,mid,tr[p].l,k); else tr[q].r = add(mid+1,r,tr[p].r,k); tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt; return q; &#125; int query(int l,int r,int p,int q)&#123; int mid = l + r &gt;&gt; 1; if(l == r) &#123;return tr[q].cnt - tr[p].cnt; &#125; int cnt1 = tr[tr[q].l].cnt - tr[tr[p].l].cnt; int cnt2 = tr[tr[q].r].cnt - tr[tr[p].r].cnt; if(cnt1 &gt; cnt2)return query(l,mid,tr[p].l,tr[q].l); else if(cnt1&lt;cnt2)return query(mid+1,r,tr[p].r,tr[q].r); else return 0; &#125; void solve()&#123; read(n);read(q); rep(i,1,n)read(a[i]),root[i] = add(1,n,root[i-1],a[i]); while(q--)&#123; int u,v; read(u);read(v); int sum = query(1,n,root[u-1],root[v]); int lens = v - u + 1; int mx = ceil(lens/2.0); if(sum &lt;= mx)&#123; pc(&#x27;1&#x27;); &#125; else &#123; int k = lens - sum; k++; write(sum-k+1); &#125; pc(&#x27; &#x27;); &#125; &#125; signed main()&#123;solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.KillAnton(CodeforcesRound#723(Div.2)题解)xiaodangao","path":"/2021/06/01/D. Kill Anton(Codeforces Round #723 (Div. 2)题解)-xiaodangao/","content":"题目链接：D. Kill Anton 思路：先考虑他会怎么做才能最少次数还原串。我们发现对于一个串b若将它还原成串a，最好是每一次交换，都减少一个逆序对数量，这里的逆序对数量是以a为中心来说的。这显然是最优解，因为当b相对于a的逆序对数量减为0时，b=a。而且他的交换方式是相邻两个字符间进行交换，所以每一次交换最多减少一个逆序对数量。那我们考虑如何才能产生最多的逆序对的数量，首先我们先看一下只有两个字符的情况： (A1)NNNN(A2)NN(A3)N(A_1)NNNN(A_2)NN(A_3)N(A1​)NNNN(A2​)NN(A3​)N 为了方便，将A每一个都标上了序号，我们发现A1A_1A1​一直移动到A2A_2A2​的位置，都在不断地产生逆序对，如果A1A_1A1​再向后移动，那么当前移动的就不是A1A_1A1​了，那我们可以看成是A2A_2A2​移动，A1A_1A1​停在原来A2A_2A2​的位置，那么显然，A1A_1A1​停在原来A2A_2A2​的位置就绝对不是最优解，只有A1A_1A1​，A2A_2A2​，A3A_3A3​都移动到最后面，才产生最大的逆序对数，所以我们发现，最优解构造有一种情况一定是把相同字符都放在一起，所以我们的做法就很好做了，这里我们只考虑两个字符，因为在考虑两个字符时，即使插入任意别的字符在任意的位置，也对于当前字符排列的逆序对没有什么影响。然后我们暴力枚举字符对，算出每一种字符对的贡献，最后利用全排列函数来求解最优解。 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb emplace_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e2+10; int _; string a,tmp = &quot;ANTO&quot;,s = &quot;ANTO&quot;; //int id[N] bool st[100010]; vector&lt;int&gt;G[N];int id[N][N]; ll cnt[N][N]; void iniv()&#123; for(auto p:tmp)for(auto k:tmp)cnt[p-&#x27;A&#x27;][k-&#x27;A&#x27;] = 0; &#125; int cnts[N]; ll work(string s)&#123; ll ans = 0; rep(i,0,3)&#123; rep(j,i+1,3)&#123; ans += cnt[s[i]-&#x27;A&#x27;][s[j]-&#x27;A&#x27;]; &#125; &#125; return ans; &#125; void solve()&#123; ios::sync_with_stdio(false); cin&gt;&gt;_; while(_--)&#123; iniv(); string b = &quot;&quot;; cin&gt;&gt;a; memset(cnts,0,sizeof cnts); for(auto p:a)&#123; cnts[p-&#x27;A&#x27;]++; &#125; //iniv(); rep(i,0,3)&#123; rep(j,i+1,3)&#123; //if(p == k)continue; ll l = 0,r = 0, ansl = 0,ansr = 0; rep(p,0,(int)a.size()-1)if(a[p] == tmp[i])l++;else if(a[p] == tmp[j])ansl += l; bep(p,(int)a.size()-1,0)if(a[p] == tmp[i])r++;else if(a[p] == tmp[j])ansr += r; cnt[tmp[j]-&#x27;A&#x27;][tmp[i]-&#x27;A&#x27;] = ansl; cnt[tmp[i]-&#x27;A&#x27;][tmp[j]-&#x27;A&#x27;] = ansr; &#125; &#125; sort(s.begin(),s.end()); ll mx = -1;// do&#123; ll now = work(s); if(now&gt;mx)b = s,mx = now; // cout&lt;&lt;s&lt;&lt;&#x27;:&#x27;&lt;&lt;now&lt;&lt;endl; &#125;while(next_permutation(s.begin(),s.end())); for(auto p:b)&#123; rep(i,1,cnts[p-&#x27;A&#x27;])cout&lt;&lt;p; &#125; cout&lt;&lt;endl; &#125; &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"B.StrangeDefinition(CodeforcesRound#694(Div.1)题解)xiaodangao","path":"/2021/05/28/B. Strange Definition(Codeforces Round #694 (Div. 1)题解)-xiaodangao/","content":"题目链接：B. Strange Definition 思路：因为gcd(x,y)=p1min∗p2min∗...∗pnmingcd(x,y) = p_1^{min}*p_2^{min}*...*p_n^{min}gcd(x,y)=p1min​∗p2min​∗...∗pnmin​，lcm(x,y)=p1max∗p2max∗...∗pnmaxlcm(x,y) = p_1^{max}*p_2^{max}*...*p_n^{max}lcm(x,y)=p1max​∗p2max​∗...∗pnmax​，所以任意两个点间若能相关，则必有lcm(x,y)gcd(x,y)=p1max−min∗p2max−min∗...∗pnmax−min\\frac{lcm(x,y)}{gcd(x,y)} = p_1^{max-min}*p_2^{max-min}*...*p_n^{max-min}gcd(x,y)lcm(x,y)​=p1max−min​∗p2max−min​∗...∗pnmax−min​其中max−minmax-minmax−min一定为偶数，即x,yx,yx,y每一个素因子的个数的奇偶性相同，然后我们发现在经过一秒之后会变成什么样，以一个节点x为例，设与x相关的集合为a1,a2,...,ana_1,a_2,...,a_na1​,a2​,...,an​,分类讨论： 1.因为和x相关的一定是对于x每一个素因子个数奇偶性均相同的，所以如果x的一个素因子个数为偶数，那么在经过一秒之后x对于该素因子变为p∑1ncnt(ai)p^{\\sum_1^n{cnt(a_i)}}p∑1n​cnt(ai​)所以在经过一秒后，与变化前奇偶性相同。 2.如果x的一个素因子个数为奇数， （1）如果与x相关的集合数目为偶数，那么p∑1ncnt(ai)p^{\\sum_1^n{cnt(a_i)}}p∑1n​cnt(ai​)的指数位置∑1ncnt(ai)\\sum_1^n{cnt(a_i)}∑1n​cnt(ai​)一定为偶数，所以经过一秒之后变为偶数，返回到第一种状态。 （2）如果与x相关的集合数目为奇数，那么p∑1ncnt(ai)p^{\\sum_1^n{cnt(a_i)}}p∑1n​cnt(ai​)的指数位置∑1ncnt(ai)\\sum_1^n{cnt(a_i)}∑1n​cnt(ai​)一定为奇数，所以无论经过几秒，都是奇数。 所以我们可以根据每一个素因子的奇偶性，将数组分到一些集合中去，方法主要为通过Hash的方式分配集合，然后记录集合最大值，然后对于每一次询问，第0秒是一个答案，非第0秒是一个答案（因为在第1秒有奇-&gt;偶的情况）。复杂度Θ(nlog(n))\\Theta(nlog(n))Θ(nlog(n)) Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb emplace_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e6+10,M = 3e5+55,inf = 1e6; const ull P = 1e9+7; int _,n; bool st[N]; int prime[N],tot; void getprime()&#123; rep(i,2,inf)&#123; if(st[i] == false)&#123; prime[++tot] = i; if(i&gt;10000)continue; for(int j=i*i;j&lt;=inf;j+=i)st[j] = true; &#125; &#125; &#125; unordered_map&lt;ull,vector&lt;int&gt; &gt;S; int a[M],q; int mx = -1; ull ids = -1; ull arr[M];int tt; void work(int x,int idx)&#123; int id = 1; ull sum = 0; while(prime[id] * prime[id] &lt;= x)&#123; int cnt = 0; while(x%prime[id] == 0)x/=prime[id],cnt++; if(cnt%2)sum = sum*P + prime[id]; id++; &#125; if(x!=1)sum = sum * P + x; S[sum].pb(idx); if((int)S[sum].size()&gt;mx)&#123; ids = sum; mx = (int)S[sum].size(); &#125; if((int)S[sum].size() == 1 and sum != 0)arr[++tt] = sum; &#125; void solve()&#123; getprime(); read(_); while(_--)&#123; tt = 0;mx = -1;ids = -1; S.clear(); read(n); rep(i,1,n)&#123; read(a[i]); work(a[i],i); &#125; int nxt = (int)S[0].size(); rep(i,1,tt)&#123; if((int)S[arr[i]].size()%2==0)nxt+=(int)S[arr[i]].size(); &#125; nxt = max(mx,nxt); read(q); while(q--)&#123; ll k; read(k); if(k)write(nxt); else write(mx); pc(&#x27; &#x27;); &#125; &#125; &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"F.UnusualMatrix(CodeforcesRound#697(Div.3)题解)xiaodangao","path":"/2021/05/27/F. Unusual Matrix(Codeforces Round #697 (Div. 3)题解)-xiaodangao/","content":"题目链接：F. Unusual Matrix 思路：我们可以发现，如果ai,ja_{i,j}ai,j​不等于bi,jb_{i,j}bi,j​那么他们变化的次数一定是奇数次，否则一定是偶数次，而该元素变化的总次数是行变化次数+列变化次数，所以我们通过a1,1a_{1,1}a1,1​就能将1行和1列的情况枚举出来，进一步，因为我们知道其他元素的情况，所以我们就可以推出来其他行和其他列的变化次数的情况，然后再带入矩阵进行验证。 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb emplace_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e3+10; int _,n; char a[N][N],b[N][N]; int row[N],col[N]; bool check(int x,int y)&#123; row[1] = x; col[1] = y; rep(i,2,n)&#123; if(b[1][i] == a[1][i])row[i] = col[1]; else row[i] = !col[1]; &#125; rep(i,2,n)&#123; if(b[i][1] == a[i][1])col[i] = row[1]; else col[i] = !row[1]; &#125; rep(i,1,n)&#123; rep(j,1,n)&#123; if(b[i][j] == a[i][j] and col[i]!=row[j])return false; if(b[i][j] != a[i][j] and col[i]==row[j])return false; &#125; &#125; return true; &#125; void solve()&#123; read(_); while(_--)&#123; read(n); rep(i,1,n)scanf(&quot;%s&quot;,a[i]+1); rep(i,1,n)scanf(&quot;%s&quot;,b[i]+1); //rep(i,1,n)puts(b[i]+1); bool flag = false; if(b[1][1] == a[1][1])&#123; if(check(1,1) or check(0,0))flag = true; &#125; else if(check(1,0) or check(0,1))flag = true; if(flag)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125; &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.CleaningthePhone(CodeforcesRound#697(Div.3)题解)xiaodangao","path":"/2021/05/27/D. Cleaning the Phone(Codeforces Round #697 (Div. 3)题解)-xiaodangao/","content":"题目链接：D. Cleaning the Phone 思路：考虑先将物品按价值排好，然后我们从高向低拿，一旦有拿大于等于m价值的东西，我们就停止。这时候发现如果我们的物品体积都是1的话，现在肯定是最优的答案，现在拿的物品体积一定是最优的。当我们考虑到有体积为2的物品存在时，我们现在肯定是选择某些体积为1的商品去替换我们曾经选过的体积为2的商品（再继续拿体积为2的商品就没有意义了），这时候我们就开始遍历剩下的体积为1的商品。设sumsumsum为当前选择物品的总价值，a数组表示每件物品的价值，valvalval表示当前已经选择的且体积为2的物品中价值最小的一件，我们会发现产生以下2种情况： sum−val+ai&gt;=msum - val + a_i&gt;=msum−val+ai​&gt;=m说明用当前这件体积为1的物品可以替换体积为2的物品。 sum−val+ai&lt;msum - val + a_i&lt;msum−val+ai​&lt;m但val&lt;=ai+ai+1val&lt;=a_i + a_{i+1}val&lt;=ai​+ai+1​这时候说明我们选择现在最大的两件物品，总价值优于我们选择一件体积为2的物品，这时候我们肯定选择这两件物品，因为这能在体积不变的前提下，使价值更高，这说明下面再进行时我们可以替换更多的物品。 最后维护的便是答案了。 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb emplace_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e5+10; int _,n;ll m,c[N]; struct node&#123; ll a; int b; bool operator&lt;(node &amp;c)const&#123; return c.a&lt;a; &#125; &#125;a[N]; ll pop[N],tot,cur[N]; void solve()&#123; read(_); while(_--)&#123; tot = 0; read(n);read(m); rep(i,1,n)read(c[i]); int x; rep(i,1,n)read(x),a[i] = &#123;c[i],x&#125;; sort(a+1,a+1+n); ll sum = 0ll;int ans = 0; int idx = n+1; rep(i,1,n)&#123; sum += a[i].a; ans += a[i].b; if(a[i].b == 2)&#123;pop[++tot] = i; &#125; if(sum &gt;= m)&#123;idx = i+1;break; &#125; &#125; if(sum &lt; m)ans = -1; else &#123; int tt = 0; rep(i,idx,n)&#123; if(a[i].b == 2)continue; cur[++tt] = a[i].a; &#125; rep(i,1,tt)&#123; if(!tot)break; ll now = a[pop[tot]].a; if(sum - now + cur[i]&gt;=m)&#123; sum = sum - now + cur[i]; ans--;tot--; &#125; else &#123; if(i!=tt)&#123; if(now&lt;=cur[i] + cur[i+1])&#123; sum -= now; sum += cur[i] + cur[i+1]; tot--;i++; &#125; &#125; &#125; &#125; &#125; write(ans);pc(&#x27; &#x27;); &#125; &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"A.NezzarandBoard(CodeforcesRound#698(Div.1)题解)xiaodangao","path":"/2021/05/26/A. Nezzar and Board(Codeforces Round #698 (Div. 1)题解)-xiaodangao/","content":"思路：发现2x-y实际就是y关于x的对称操作，然后因为我们只有这一种操作，将所有元素放在一个数轴上可以发现，整体平移任意单位对于整体来说并没有影响。又因为我们发现如果原数组中有0，那么我们就可以通过这个操作来求出任意倍数的xix_ixi​，进一步的，我们可以求出所有gcd(x1,x2,...,xn)gcd(x_1,x_2,...,x_n)gcd(x1​,x2​,...,xn​)的倍数的数，因此，当且仅当此时的kkk（即k−x1k-x_1k−x1​）是gcdgcdgcd倍数，才能通过该数组构成kkk。 Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : C.cpp @Time : 2021/05/25 11:15:07 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define lc(p) p&lt;&lt;1 #define rc(p) p&lt;&lt;1|1 #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e5+10; int _; int n;ll k,a[N]; void solve()&#123; read(_); while(_--)&#123; read(n);read(k); rep(i,1,n)&#123; read(a[i]); &#125; sort(a+1,a+1+n); ll ans = a[2] - a[1]; rep(i,3,n)ans = __gcd(ans,a[i]-a[1]); if((k-a[1])% ans)puts(&quot;NO&quot;); else puts(&quot;YES&quot;); &#125; &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.MaxMedian(CodeforcesRound#703(Div.2)题解)xiaodangao","path":"/2021/05/20/D. Max Median(Codeforces Round #703 (Div. 2)题解)-xiaodangao/","content":"题目链接：D. Max Median 思路：二分答案，因为直接找的话肯定是不行的，因为区间共有∑i=1ni\\sum_{i=1}^{n}{i}∑i=1n​i复杂度θ(n2)\\theta(n^2)θ(n2),所以我们需要思考，既然暴力查询不可以，我们逆向思维，给你一个数，你是否能在θ(n)\\theta(n)θ(n)的时间内求出该数组有一段区间中位数要大于等于该数，这个判断是能够实现的，这是因为如果一个数能做中位数，那么一段区间内大于等于该数的数量一定大于等于⌈n+12⌉\\lceil \\frac{n+1}{2} \\rceil⌈2n+1​⌉，我们可以把原数组小于该数的看做-1，大于等于该数的看做1，然后求一遍前缀和，然后我们发现题意就变为求一段大于等于k区间内sumsumsum的最大值，如果最大值大于0，那么就是1的数量要比-1的数量多，所以该答案被允许，我们可以利用定右端点的方式，首先右端点设为k，那么显然答案只有[1,k]这一个，这时最优左端点是1，那么如果我们右端点向右移动1格，那么现在左端点的选择又多了一个，那就是2这个点（即[2,k+1]）令区间满足最大就是令左端点对应的前缀和值最小，就这样一直右移右端点，每次进入决策集合的只有一个点，我们可以求最小值来进行决策。然后的工作就好做了，二分答案判断是否合法。 Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : D.cpp @Time : 2021/05/19 19:52:36 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e5+10; int n ,k; int a[N],sum[N]; bool check(int p)&#123; rep(i,1,n)&#123; sum[i] = sum[i-1]; if(a[i]&gt;=p)sum[i]++; else sum[i]--; &#125; int idx = 0; rep(i,k,n)&#123; int now = sum[i] - sum[idx]; if(now &gt; 0)return true; if(sum[i-k+1]&lt;=sum[idx])idx = i-k+1; &#125; // if(sum[n]-sum[idx]&gt;0)return true; return false; &#125; void solve()&#123; read(n);read(k); int l = 9999999,r = -1; rep(i,1,n)&#123; read(a[i]);l = min(l,a[i]);r = max(r,a[i]); &#125; while(l&lt;r)&#123; int mid = l + r + 1 &gt;&gt; 1; if(check(mid))l = mid; else r = mid - 1; &#125; write(r);pc(&#x27; &#x27;); &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"1516CBabyEhabPartitionsAgain(CodeforcesRound#717(Div.2)题解)xiaodangao","path":"/2021/05/18/1516C - Baby Ehab Partitions Again(Codeforces Round #717 (Div. 2)题解)-xiaodangao/","content":"题目链接：1516C - Baby Ehab Partitions Again 思路：背包判断sum2\\frac{sum}{2}2sum​是否能够组成，如果不可以，答案显然，否则进行缩放，因为我们处理该规模/GCD的数比我们直接处理该规模的数的好处体现在，将该规模数除以GCD之后，绝对不可能全是偶数的存在，因为如果全是偶数，那么显然现在gcd不为1，所以一定存在一个奇数，在缩放之后处理该奇数，就是答案，因为有答案，所以缩放后的sum和肯定也是偶数，那么偶数-奇数=奇数，所以一定不可能构成两个相同的集合。 Code:Code:Code: #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;unordered_map&gt; #include &lt;vector&gt; #define rep(i, a, b) for (auto i = a; i &lt;= b; ++i) #define bep(i, a, b) for (auto i = a; i &gt;= b; --i) #define ch() getchar() #define pc(x) putchar(x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) #define mst fflush(stdout) using namespace std; template &lt;typename T&gt; void read(T&amp; x) &#123; static char c; static int f; for (c = ch(), f = 1; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c = ch()) if (c == &#x27;-&#x27;) f = -f; for (x = 0; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = ch()) x = x * 10 + (c &amp; 15); x *= f; &#125; template &lt;typename T&gt; void write(T x) &#123; static char q[65]; int cnt = 0; if (x &lt; 0) pc(&#x27;-&#x27;), x = -x; q[++cnt] = x % 10, x /= 10; while (x) q[++cnt] = x % 10, x /= 10; while (cnt) pc(q[cnt--] + &#x27;0&#x27;); &#125; const int N = 1e5+11; int n,a[N],f[N]; void solve()&#123; read(n); int sum = 0; int id = -1; int mi = 9999999; rep(i,1,n)&#123; read(a[i]);sum += a[i]; if(a[i]%2)id = i;mi = min(mi,a[i]); &#125; if(sum % 2)&#123; pc(&#x27;0&#x27;);return ; &#125; sum/=2; rep(i,1,n)&#123; bep(j,sum,a[i])&#123; f[j] = max(f[j],f[j-a[i]]+a[i]); &#125; &#125; if(f[sum] != sum)&#123; pc(&#x27;0&#x27;);return ; &#125; int now = a[1]; rep(i,2,n)&#123;now = __gcd(now,a[i]);&#125; rep(i,1,n)&#123; if((a[i]/now)%2)&#123; printf(&quot;1 %d &quot;,i);return ; &#125; &#125; &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.Cut（CodeforcesRound#717(Div.2)题解）xiaodangao","path":"/2021/05/18/D. Cut（Codeforces Round #717 (Div. 2)题解）-xiaodangao/","content":"题目链接：D. Cut 思路：首先进行双指针求nxt数组，该nxt数组定义是在该点最远能到达的点，求法是利用双指针，如果发现一个数的质因子在前面出现过，那就说明第一个指针已经得到了他的nxt数组答案。求完nxt数组后，本来我的想法是将每一个下标所对应的能到达的位置，就是一条链写入vector，然后利用二分的方法进行计算，不过该种想法空间会被卡爆，是因为如果前面几个nxt数组都指向同一个数，那么就会多开了几倍的空间。标准做法是利用倍增的思想，sum[i,j]=sum[sum[i,j−1],j−1]sum[i,j] = sum[sum[i,j-1],j-1]sum[i,j]=sum[sum[i,j−1],j−1]，sum[i,j]sum[i,j]sum[i,j]意为i从跳跃2j−12^{j-1}2j−1次所能到达的答案，求出来之后我们就可以对他的每一次(l,r)(l,r)(l,r)询问进行计算，首先枚举出第一个小于r的是需要l跳多少次，再令l=该值，然后就这样进行下去。 Code:Code:Code: #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;unordered_map&gt; #include &lt;vector&gt; #define rep(i, a, b) for (auto i = a; i &lt;= b; ++i) #define bep(i, a, b) for (auto i = a; i &gt;= b; --i) #define ch() getchar() #define pc(x) putchar(x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) #define mst fflush(stdout) using namespace std; template &lt;typename T&gt; void read(T&amp; x) &#123; static char c; static int f; for (c = ch(), f = 1; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c = ch()) if (c == &#x27;-&#x27;) f = -f; for (x = 0; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = ch()) x = x * 10 + (c &amp; 15); x *= f; &#125; template &lt;typename T&gt; void write(T x) &#123; static char q[65]; int cnt = 0; if (x &lt; 0) pc(&#x27;-&#x27;), x = -x; q[++cnt] = x % 10, x /= 10; while (x) q[++cnt] = x % 10, x /= 10; while (cnt) pc(q[cnt--] + &#x27;0&#x27;); &#125; const int N = 1e5+1; vector&lt;int&gt;G[N]; int sum[N][33]; int n,q; int st[N][2],sizes[N]; int a; bool vis[N]; int prime[N]; int tot ; int nxt[N],pr[N]; bool v[N]; void getprime()&#123; rep(i,2,100000)&#123; if(!vis[i])&#123; prime[++tot] = i; if(i&gt;1000)continue; for(int j=i*i;j&lt;=100000;j+=i)&#123; vis[j] = true; &#125; &#125; &#125; &#125; void getval(int x,int idx)&#123; int id = 1; while(prime[id] * prime[id] &lt;= x)&#123; bool flag = false; while(x%prime[id] == 0)x/=prime[id],flag = true; if(flag)G[idx].pb(prime[id]); id++; &#125; if(x==1)return ; G[idx].pb(x); &#125; int t[N]; void solve()&#123; getprime(); rep(i,1,100000)&#123; getval(i,i); &#125; read(n);read(q); rep(i,1,n)read(a),t[i] = a; int id = -1; rep(i,1,n)&#123; for(auto p:G[t[i]])&#123; if(sizes[p])&#123;id = i;&#125; st[p][sizes[p]]=i,sizes[p]++; &#125; if(id != -1)break; &#125; int mx = -1; if(id == -1)&#123; mx = n;id = n+1; &#125; for(auto p:G[t[id]])&#123;if(st[p][0] == id)continue; mx = max(mx,st[p][0]);&#125; rep(i,1,mx)nxt[i] = id-1; int i = mx+1, j = id+1; while(i&lt;=n)&#123; int idx = -1; rep(k,j,n)&#123; for(auto p:G[t[k]])&#123; if(sizes[p] and st[p][sizes[p]-1]&gt;=i)&#123;idx = k; &#125; //st[p].pb(k); if(sizes[p] == 2)&#123; st[p][0] = st[p][1]; st[p][1] = k; &#125; else if(sizes[p] == 1)&#123; st[p][1] = k;sizes[p] = 2; &#125; else if(sizes[p] == 0)&#123; st[p][0] = k;sizes[p] = 1; &#125; &#125; if(idx != -1)break; &#125; //第一个成功的 mx = -1; if(idx == -1)&#123; idx = n+1; mx = n; &#125; for(auto p:G[t[idx]])&#123; int lens = sizes[p]; if(lens == 1)continue; if(st[p][lens-2]&gt;=i)mx = max(mx,st[p][lens-2]); &#125; rep(k,i,mx)nxt[k] = idx-1; i = mx + 1, j = idx + 1; &#125; v[n] = true; rep(i,1,n)&#123; int id = i; sum[id][1] = nxt[id]+1; &#125; rep(i,0,30)sum[n+1][i] = n+1; bep(i,n,1)&#123; rep(j,2,30)&#123; sum[i][j] = sum[sum[i][j-1]][j-1]; &#125; &#125; rep(test,1,q)&#123; int u,v; int ans = 0; read(u);read(v); bep(i,30,1)&#123; if(sum[u][i]&lt;=v)&#123; ans += (1&lt;&lt;(i-1)); u = sum[u][i]; &#125; &#125; write(ans+1);pc(&#x27; &#x27;); &#125; &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"902.最短编辑距离xiaodangao","path":"/2021/05/17/902. 最短编辑距离-xiaodangao/","content":"水一发题解； 题目链接：902. 最短编辑距离 思路：f(i,j)f(i,j)f(i,j)表示第一个串只看前i个字符，第二个串只看前j个字符，将串1转化成串2的最小操作数，枚举最后一个字符的操作：如果最后一个字符的操作是删除，那么答案为f(i−1,j)+1f(i-1,j)+1f(i−1,j)+1,否则如果最后一个字符的操作是插入，那么答案为f(i,j−1)+1f(i,j-1)+1f(i,j−1)+1，如果最后一个字符操作是替换，那么答案为f(i−1,j−1)+1f(i-1,j-1)+1f(i−1,j−1)+1。特别的，如果ch1[i]==ch2[j]ch1[i]==ch2[j]ch1[i]==ch2[j]那么最后一步不用替换，答案是f(i−1,j−1)f(i-1,j-1)f(i−1,j−1) Code:Code:Code: #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 1e3+10; string str1,str2; int n,m; int f[N][N]; void solve()&#123; cin&gt;&gt;n; cin&gt;&gt;str1; cin&gt;&gt;m; cin&gt;&gt;str2; str1 = &quot;1&quot;+str1; str2 = &quot;1&quot;+str2; for(int i=1;i&lt;=n;++i)f[i][0] = i; for(int i=1;i&lt;=m;++i)f[0][i] = i; for(int j=1;j&lt;=m;++j)&#123; for(int i=1;i&lt;=n;++i)&#123; int sum =0; if(str1[i] == str2[j])&#123; sum = f[i-1][j-1]; &#125; else sum = f[i-1][j-1] + 1; sum = min(min(f[i-1][j],f[i][j-1])+1,sum); f[i][j] = sum; // cout&lt;&lt;f[i][j]&lt;&lt;&#x27; &#x27;; &#125; //cout&lt;&lt;endl; &#125; cout&lt;&lt;f[n][m]&lt;&lt;endl; &#125; signed main()&#123; solve();return 0;&#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.ExplorerSpace(Contest2050andCodeforcesRound#718(Div.1+Div.2)题解)xiaodangao","path":"/2021/05/14/D. Explorer Space(Contest 2050 and Codeforces Round #718 (Div. 1 + Div. 2)题解)-xiaodangao/","content":"题目链接：D. Explorer Space 思路：记忆化搜索。。。。。。。因为他说k步以内并且回到原点，并且可以走回头路，所以一定是找出到在i,j,k/2步能够到达的位置的最小价值，然后原路返回就是最佳答案。 Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : D.cpp @Time : 2021/05/14 15:41:43 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ch() getchar() #define pc(x) putchar(x) #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) x&amp;(-x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 5e2+10; map&lt;pair&lt;pair&lt;int,int&gt;, pair&lt;int,int&gt; &gt;,int &gt;G; int n,m,k; int f[N][N][33]; int b[N][N],s[14][14]; int st[N][N]; int l[] = &#123;0,0,-1,1&#125;,r[] = &#123;1,-1,0,0&#125;; int dfs(int idx,int idy,int step)&#123; if(step == 0)return 0; if(f[idx][idy][step])return f[idx][idy][step]; int ans = 99999999; rep(i,0,3)&#123; int x = idx + l[i], y = idy + r[i]; if(x &gt; n or x &lt; 1 or y &gt; m or y &lt; 1)continue; int h = dfs(x,y,step-1); ans = min(ans,h + G[&#123;&#123;x,y&#125;,&#123;idx,idy&#125;&#125;]); &#125; return f[idx][idy][step] = ans; &#125; void solve()&#123; int x,y; read(n);read(m);read(k); rep(i,1,n)&#123; rep(j,1,m-1)read(x),G[&#123;&#123;i,j&#125;,&#123;i,j+1&#125;&#125;] = G[&#123;&#123;i,j+1&#125;,&#123;i,j&#125;&#125;] = x; &#125; rep(i,1,n-1)&#123; rep(j,1,m)read(y),G[&#123;&#123;i,j&#125;,&#123;i+1,j&#125;&#125;] = G[&#123;&#123;i+1,j&#125;,&#123;i,j&#125;&#125;] = y; &#125; if(k % 2)&#123; rep(i,1,n)&#123; rep(j,1,m)printf(&quot;-1 &quot;);pc(&#x27; &#x27;); &#125;return ; &#125; rep(i,1,n)&#123; rep(j,1,m)&#123; printf(&quot;%d &quot;,dfs(i,j,k/2)*2); &#125; pc(&#x27; &#x27;); &#125; &#125; signed main()&#123; solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"C.NastiaandaHiddenPermutation(CodeforcesRound#720(Div.2)题解)xiaodangao","path":"/2021/05/14/C. Nastia and a Hidden Permutation(Codeforces Round #720 (Div. 2)题解)-xiaodangao/","content":"题目链接：C. Nastia and a Hidden Permutation 思路：求出1的位置是关键，因为我们一旦求出来1的位置，我们就可以通过n-1次询问确定其他剩余的位置:设1的位置为x，则这样询问：【1 x i n-1】，这样询问首先求min(1,n−1)=1，min(ai,n)=aimin(1,n-1) = 1，min(a_i,n) = a_imin(1,n−1)=1，min(ai​,n)=ai​再求max(ai,1)=aimax(a_i,1) = a_imax(ai​,1)=ai​所以得到的数就是aia_iai​。那么剩下的问题就变成了如何通过不超过n2+30\\frac{n}{2}+302n​+30次询问求出来1的位置，我们可以利用第2种询问方法，【2 i-1 i 1】分类讨论：这种询问如果ai−1a_{i-1}ai−1​和aia_{i}ai​的值都大于2的话，那么值肯定是min(ai,ai−1)min(a_i,a_{i-1})min(ai​,ai−1​)，如果有小于等于2的数，那么该询问可能为1，可能为2，如果为1，那好办了，那1的位置就是ai−1a_{i-1}ai−1​，否则这全部询问如果只有1个为2值的情况，那么说明该对的分布是2 1，因为只有这样才有可能是只有1个2值出现，那如果有2个为2值的情况，那么说明1的位置一定在aia_iai​的位置，枚举aia_iai​的位置就可以得到答案。 Code:Code:Code: /* -*- encoding: utf-8 -*- &#x27;&#x27;&#x27; @File : C.cpp @Time : 2021/05/14 14:22:26 @Author : puddle_jumper @Version : 1.0 @Contact : 1194446133@qq.com &#x27;&#x27;&#x27; # here put the import lib*/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;unordered_map&gt; #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define ch() getchar() #define pc(x) putchar(x) #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define PI acos(-1) #define mst fflush(stdout) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e4+10; int _,n; int a[N],id[N],idx; int ans[N]; void doit()&#123; ans[idx] = 1; int t; rep(i,1,n)&#123; if(i == idx)continue; printf(&quot;? 1 %d %d %d &quot;,idx,i,n-1); mst; scanf(&quot;%d&quot;,&amp;t); ans[i] = t; &#125; printf(&quot;!&quot;); rep(i,1,n)printf(&quot; %d&quot;,ans[i]);pc(&#x27; &#x27;); mst; &#125; void solve()&#123; read(_); while(_--)&#123; read(n); int k; bool flag = false; int tot = 0; for(int i=2;i&lt;=n;i+=2)&#123; printf(&quot;? 2 %d %d %d &quot;,i-1,i,1); mst; scanf(&quot;%d&quot;,&amp;k); a[i] = k; if(a[i] == 1)&#123; flag = true;id[1] = i;tot = 1; &#125; else if(a[i] == 2)&#123; id[++tot] = i; &#125; &#125; if(n%2)&#123; printf(&quot;? 2 %d %d %d &quot;,n-1,n,1); mst; scanf(&quot;%d&quot;,&amp;k);a[n] = k; if(a[n] == 1)&#123; flag = true;id[1] = n;tot = 1; &#125; else if(a[n] == 2)&#123; id[++tot] = n; &#125; &#125; if(flag == false)&#123; if(tot == 2)&#123; printf(&quot;? 2 %d %d %d &quot;,id[1],id[2],1); mst; scanf(&quot;%d&quot;,&amp;k); if(k == 1)idx = id[1]; else idx = id[2]; &#125; else &#123; idx = id[1]; &#125; &#125; else &#123; idx = id[1]-1; &#125; doit(); &#125; &#125; signed main()&#123;solve();return 0;&#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.GCDofanArray(CodeforcesRound#705(Div.2)题解)xiaodangao","path":"/2021/05/13/D. GCD of an Array(Codeforces Round #705 (Div. 2)题解)-xiaodangao/","content":"题目链接：D. GCD of an Array 思路：纯纯的数据结构题目，一看数据范围2e52e52e5很显然是维护每一个质数的最小的个数，2e52e52e5内的素数个数不超过2e42e42e4，所以我们对于每一个素数用一个map来存对于aia_iai​的该素因子的个数，然后用另外一个map存反（其实可以用multiset代替），另一个我们只需要知道个数，然后求最小值操作也是用存反的map完成的，因为内部是用key进行排序的。 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x) &#123; static char c; static int f; for(c=ch(),f=1; c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;; c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0; c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; c=ch())x=x*10+(c&amp;15); x*=f; &#125; template&lt;typename T&gt;void write(T x) &#123; static char q[65]; int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e5+10; const ll mod = 1e9+7; const int M = 2e4+10; int prime[N]; map&lt;int,int&gt;S[M],P[M]; int tot = 0; bool st[N]; int n,q,a[N]; int up[N]; long long q_pow(long long base, long long power) &#123; long long result = 1; while (power &gt; 0) &#123; if (power &amp; 1) &#123; result = result * base ; &#125; power &gt;&gt;= 1; base = (base * base) ; &#125; return result; &#125; void _prime() &#123; rep(i,2,2e5) &#123; if(st[i] == false) &#123; prime[++tot] = i; up[i] = prime[tot]; if(i&gt;1e4)continue; for(int j=i*i; j&lt;=2e5; j+=i) &#123; st[j] = true; &#125; &#125; &#125; &#125; void init(int x,int idx) &#123; int id = 1; while(prime[id] * prime[id] &lt;= x) &#123; int cnt = 0; while(x%prime[id] == 0)x/=prime[id],cnt++; if(cnt) &#123; S[id][idx] += cnt;//作访问用 P[id][cnt]++; &#125; id++; &#125; if(x == 1)return ; int k = lower_bound(prime+1,prime+1+tot,x)-prime; S[k][idx] += 1; P[k][1]++; &#125; int sum; void doit(int cnt,int id,int idx) &#123; if(!cnt)return ; bool flag = true; if((int)S[id].size() != n)flag = 0; int l = S[id][idx]; int r = l + cnt; auto it=P[id].begin(); pair&lt;int,int&gt;a1 = *it; int ans = a1.first; if(flag == false)ans = 0; S[id][idx] = r; if(l!=0) P[id][l]--; P[id][r]++; if(P[id][l] == 0) &#123; auto s = P[id].find(l); //printf(&quot;%d &quot;,*s.first); P[id].erase(s); &#125; //printf(&quot;%d %d %d %d %d &quot;,(int)S[id].size(),prime[id],l,r,ans); if((int)S[id].size()!=n) &#123; return ; &#125; //auto k=S[id].lower_bound(S[id].begin(),S[id].end(),1)-S[id].begin(); auto k = P[id].begin(); auto c = *k;//printf(&quot;%d %d &quot;,c.first,c.second); if(c.first == ans)return; sum *= (ll)q_pow(prime[id],c.first-ans); // printf(&quot;%d &quot;,prime[id]); &#125; int add(int x,int idx) &#123; int id = 1; sum = 1; while(prime[id] * prime[id] &lt;= x) &#123; int cnt = 0; while(x%prime[id] == 0)x/=prime[id],cnt++; doit(cnt,id,idx); id++; &#125; if(x == 1)return sum; auto k = lower_bound(prime+1,prime+1+tot,x)-prime; doit(1,k,idx); return sum ; &#125; int _; void solve() &#123; _prime(); read(n); read(q); int sum; rep(i,1,n) &#123; read(a[i]); init(a[i],i); if(i == 1)sum = a[i]; else sum = __gcd(sum,a[i]); &#125; ll now = sum*1ll; while(q--) &#123; int idx,v; read(idx); read(v); now *=add(v,idx)%mod; now %=mod; write(now);pc(&#x27; &#x27;); &#125; &#125; signed main() &#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.TheNumberofPairs(EducationalCodeforcesRound106(RatedforDiv.2)题解)xiaodangao","path":"/2021/05/13/D. The Number of Pairs(  Educational Codeforces Round 106 (Rated for Div. 2)题解)-xiaodangao/","content":"题目链接：D. The Number of Pairs 思路：已知clcm(a,b)−dgcd(a,b)=xclcm(a,b) - dgcd(a,b) = xclcm(a,b)−dgcd(a,b)=x设gcd(a,b)=g,a=ig,b=jggcd(a,b)=g,a = ig,b=jggcd(a,b)=g,a=ig,b=jg。其中i,ji,ji,j互质，由于lcm(a,b)=abgcd(a,b)lcm(a,b) = \\frac{ab}{gcd(a,b)}lcm(a,b)=gcd(a,b)ab​则原式可以化成： cijg−dg=xcijg-dg=xcijg−dg=x所以g=xcij−dg=\\frac{x}{cij-d}g=cij−dx​那么分子cij−dcij-dcij−d一定是xxx的因数，然后我们可以通过枚举xxx的因数，来确定所有ijijij的取值，那么现在的问题就是对于一个 数sss，求ij=sij=sij=s个数，其中i与j互质。答案是2s素因数个数2^{s素因数个数}2s素因数个数。我们可以通过预处理，用类似于埃氏筛法的炒作来提前算好所有的数的质因数个数。 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e7+10; int prime[N]; int tot = 0;bool st[N]; void _prime()&#123; rep(i,2,2e7)&#123; if(st[i] == false)&#123; prime[++tot] = i; if(i&gt;1e4)continue; for(int j=i*i;j&lt;=2e7;j+=i)&#123; st[j] = true; &#125; &#125; &#125; &#125; int cnt[N]; void iniv()&#123; //cnt[1] = 1; rep(i,1,tot)&#123; for(int j=prime[i];j&lt;=2e7;j+=prime[i])cnt[j]++; &#125; &#125; ll pows[100]; int _; void solve()&#123; pows[0] = 1; rep(i,1,55)pows[i] = pows[i-1]*2; _prime(); iniv(); read(_); while(_--)&#123; int c,d,x; read(c);read(d);read(x); ll ans = 0; for(int i=1;i*i&lt;=x;i++)&#123; if(x%i)continue;int sum = (d+i)/c; if((d + i)%c)&#123; goto stk; &#125;//判断i×j是否为整数 ans += pows[cnt[sum]]; stk: if(i*i==x)continue; if((d+x/i)%c)continue; sum = (d+x/i)/c; ans += pows[cnt[sum]]; &#125; write(ans);pc(&#x27; &#x27;); &#125; &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"AThegameofOsho（20162017ACMICPC,EgyptianCollegiateProgrammingContest(ECPC16)）题解xiaodangao","path":"/2021/05/12/A - The game of Osho （2016-2017 ACM-ICPC, Egyptian Collegiate Programming Contest (ECPC 16)）题解-xiaodangao/","content":"题目链接：A - The game of Osho 思路：SG打表找规律，发现在b为奇数时，0、1均匀分布，b为偶数时且满足n%(b+1) = b时sg值为2，打表程序如下: Code1:Code1:Code1: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e5+10; ll b,_;int n; int f[N]; int sg(int id)&#123; if(f[id] != -1)return f[id]; set&lt;int&gt;S; ll p = 1; while(p&lt;=id)&#123; S.insert(sg(id-p)); p=b*p; &#125; int now = 0; while(S.count(now))now++; f[id] = now; return now; &#125; void solve()&#123; while(true)&#123; memset(f,-1,sizeof f);f[0] = 0;f[1] = 1; read(b);read(n); rep(i,0,n)&#123; if(sg(i)==2)printf(&quot;%d &quot;,i); &#125; &#125; &#125; signed main()&#123;solve(); return 0; &#125; AC代码如下： Code2:Code2:Code2: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e5+10; ll b,_;int n; int f[N]; int sg(int id)&#123; if(f[id] != -1)return f[id]; set&lt;int&gt;S; ll p = 1; while(p&lt;=id)&#123; S.insert(sg(id-p)); p=b*p; &#125; int now = 0; while(S.count(now))now++; f[id] = now; return now; &#125; void solve()&#123; freopen(&quot;powers.in&quot;,&quot;r&quot;,stdin); read(_); while(_--)&#123; int t; read(t); int ans = 0; rep(i,1,t)&#123; read(b);read(n); if(b &amp; 1)&#123; ans ^= n%2; &#125; else if(n%(b+1) == b)ans^=2; else &#123; int x = n%(b+1); ans ^= x%2; &#125; &#125; if(!ans)puts(&quot;2&quot;);else puts(&quot;1&quot;); &#125; &#125; signed main()&#123;solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"POJ.1704GeorgiaandBob(博弈)xiaodangao","path":"/2021/05/12/POJ.1704 Georgia and Bob(博弈)-xiaodangao/","content":"题目链接：Georgia and Bob 思路：之前是想的是必败态是有偶数个相邻的棋子，因为后手可以通过模仿先手的行为达到平衡，然后就能推出来两个相邻奇数堆是先手必胜，因为先手可以通过移动第二个奇数堆造成必败态。但是后来推不下去了。。。正解应该是将相邻的两个棋子视为一堆石子，那么为什么不将一个石子和他之前的石子视为一堆，从而有n堆呢？因为如果看成n堆，那么一堆向左移动时，会影响两堆的状态，这种状态是无法进行平衡操作的，而如果将相邻的棋子视为一堆的话，每一次移动只会影响一堆的状态，这样即使一个堆为0的石子被移动成9，那么后手可以直接再将其变成0，继而又轮到先手，这样不会影响到总体的状态，所以还是可以看成n/2堆石子。 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e3+10; int t,n; int arr[N],p[N]; void solve()&#123; read(t); while(t--)&#123; read(n); rep(i,1,n)&#123; read(p[i]); &#125; //sort(p+1,p+1+n); if(n%2)p[n+1] = 0,n++; int now = 0; sort(p+1,p+1+n); int ans = p[2]-p[1] - 1; rep(i,4,n)&#123; ans ^= p[i] - p[i-1] - 1; i++; &#125; if(!ans)&#123; printf(&quot;Bob &quot;); &#125; else printf(&quot;Georgia &quot;); puts(&quot;will win&quot;); &#125; &#125; signed main()&#123;solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.Digits（20202021ICPC,NERC,NorthernEurasiaOnsite题解）xiaodangao","path":"/2021/05/08/D. Digits（2020-2021 ICPC, NERC, Northern Eurasia Onsite题解）-xiaodangao/","content":"题目链接：D. Digits 思路：1e6∗101e6 * 101e6∗10的dpdpdp每次更新以k为结尾的最大值就好了（最开始的想法是正确的），有一点是因为是乘法，所以必须进行取log操作，让乘法变成加法，才不会爆。然后需要注意的是进行存放方案的操作有些许的麻烦。 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e5+10; const double eps = 1e-9; int n,d; int a[N];double b[N],f[33],c[33]; vector&lt;int&gt;G[33],ans; pair&lt;int,int&gt;tmp[33],cur[N][10]; int ma[33]; void solve()&#123; int tot = 0; read(n);read(d); rep(i,1,n)&#123;read(a[i]);b[i] = log(1.0*a[i]); &#125; //sort(a+1,a+1+n); rep(i,0,9)f[i] = -1; rep(i,1,n)&#123; tot = 0; rep(j,0,9)c[j] = f[j]; rep(j,0,9)&#123; int s = a[i] % 10; if(j == s)&#123; if(b[i]&gt;c[j])&#123; tmp[++tot] = &#123;-1,j&#125;;c[j] = max(b[i],c[j]); &#125; &#125; int h = j*a[i]%10; double p = f[j]; if(f[j] &lt; 0)continue; p += b[i]; if(p&gt;c[h] or c[h] == p)&#123; tmp[++tot] = &#123;j,h&#125;; c[h] = max(c[h],p); &#125; &#125; rep(j,1,tot)&#123; int idx = tmp[j].first,idy = tmp[j].second; cur[i][idy] = &#123;ma[idx],idx&#125;; &#125; rep(j,1,tot)ma[tmp[j].second] = i; rep(j,0,9)f[j] = max(c[j],f[j]);//,printf(&quot;%lf &quot;,f[j]);pc(&#x27; &#x27;); &#125; if(f[d] == -1)&#123; puts(&quot;-1&quot;);return ; &#125; //printf(&quot;%lf &quot;,f[d]); int idx = ma[d],idy = d; while(idx)&#123;ans.pb(a[idx]);int xx = idx,yy = idy;idx = cur[xx][yy].first,idy = cur[xx][yy].second; &#125; sort(ans.begin(),ans.end()); printf(&quot;%d &quot;,(int)ans.size()); rep(i,0,(int)ans.size()-1)printf(&quot;%d &quot;,ans[i]); //printf(&quot;%d &quot;,f[d]); &#125; signed main()&#123;solve();return 0;&#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"G.Guide(20202021ICPC,NERC,NorthernEurasiaOnsite题解)xiaodangao","path":"/2021/05/08/G.Guide(2020-2021 ICPC, NERC, Northern Eurasia Onsite题解)-xiaodangao/","content":"题目链接：G.Guide 思路：想了好久。。贪心的想法是在一颗最长链上进行不回溯操作，我们需要一遍dfs标记出最长链，然后进行第二次dfs寻找答案，我们必须让dfs“死”在最长链上，方法是如果一个节点的子节点在最长链上，那么最后再进行dfs操作。然后在dfs中记录当前标记的非最长链上的点的数量，如果达到了k−最长链上点的数量k-最长链上点的数量k−最长链上点的数量那么需要立即进行回溯到最近的最长链上的点，然后结束操作。最后再加上最长链上的某些点就可以了。PS:代码写的很麻烦 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e2+10; int _,k,n,cnt; vector&lt;int&gt;G[N],now,ans,ans1; int mx = -1,ret = 1; bool st[N]; void dfs(int id,int high)&#123;//记录 now.pb(id); for(auto p:G[id])dfs(p,high+1); if(mx &lt; high)&#123;mx = high;ans = now; &#125; now.pop_back(); &#125; bool flag = false,judge = true; void dfs2(int id)&#123; int c = -1; if(flag == true)return ; cnt++;ans1.pb(id); if(st[id])ret++; int fr = cnt - ret; if(fr + (int)ans.size() &gt;= k)&#123; flag = true; return ; &#125; int h = cnt; for(auto p:G[id])&#123; if(st[p] == true)&#123;c = p;continue; &#125; dfs2(p); if(judge == true)return ; if(flag == true and st[id] == true)&#123; if(ans1[(int)ans1.size()-1]!=id) ans1.pb(id); judge = true; return ; &#125; if(ans1[(int)ans1.size()-1]!=id) ans1.pb(id); &#125; if(c != -1)&#123; dfs2(c); if(judge == true)return ; if(flag == true and st[id] == true)&#123; if(ans1[(int)ans1.size()-1]!=id) ans1.pb(id); judge = true; return ; &#125; if(ans1[(int)ans1.size()-1]!=id) ans1.pb(id); return ; &#125; return ; &#125; void solve()&#123; read(_); while(_--)&#123; mx = -1; flag = false;judge = false; ans1.clear(); ret = 0; now.clear(); memset(st,0,sizeof st); read(n);read(k); rep(i,1,n)G[i].clear(); int t; cnt = 0; rep(i,2,n)read(t),G[t].pb(i); dfs(1,0); for(auto p:ans)st[p] = true; dfs2(1); int s = ans1[(int)ans1.size()-1]; flag = false; for(auto p:ans)&#123; if(p == s)&#123;flag = true;continue;&#125; if(flag == true and cnt &lt; k)cnt++,ans1.pb(p);//,printf(&quot;%d &quot;,p); &#125; printf(&quot;%d &quot;,(int)ans1.size()-1); for(auto p:ans1)printf(&quot;%d &quot;,p);pc(&#x27; &#x27;); &#125; &#125; signed main()&#123;solve();return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"C.TheSportsFestival(CodeforcesRound#715(Div.2))题解xiaodangao","path":"/2021/04/26/C. The Sports Festival(Codeforces Round #715 (Div. 2))题解-xiaodangao/","content":"题目链接：C. The Sports Festival 思路：区间DP，如果我们将这些数放在一个数轴上可以发现最优解的一些性质，比方说已排序后的序列[。。。。11,12,13,14]，假设我们前面已经有选择过的数了，我们选择的时候一定是先选择13在选择14，因为，设没选择13之前的最小值为minminmin，那么在按顺序13,14之后对答案的贡献是13−min+14−min13 - min + 14 - min13−min+14−min，如果不按顺序选择的话贡献是14−min+14−min14 - min + 14 - min14−min+14−min显然按顺序选择要优于隔空选择，那么我们就可以发现答案的性质，就是在一段连续的数轴中，最后一个选择的一定是最大值或最小值，根据这个性质，我们可以排序后按区间大小来枚举区间，因为该性质的存在，我们便知道了最优解最后一步，接下来就开始枚举最优解的最后一步，设f(i,j)f(i,j)f(i,j)表示区间[i,j][i,j][i,j]上的答案，那么根据最优解最后一步的策略，该答案一定是由f(i+1,j)+a[j]−a[i]f(i+1,j) + a[j] - a[i]f(i+1,j)+a[j]−a[i]（其中a[j] - a[i]代表最后一步的选择），f(i,j−1)+a[j]−a[i]f(i,j-1) + a[j] - a[i]f(i,j−1)+a[j]−a[i]，来产生的，答案取min就能得到答案。 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define x first #define y second #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e3+10; #define int long long int n,a[N],f[N][N]; void solve()&#123; read(n); rep(i,1,n)&#123; read(a[i]); &#125; sort(a+1,a+1+n); rep(i,2,n)&#123; rep(j,1,n-i+1)&#123; f[j][j+i-1] = a[j+i-1] - a[j] + min(f[j][j+i-2],f[j+1][j+i-1]); &#125; &#125; write(f[1][n]); &#125; signed main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"L3011直捣黄龙(PTA题解)xiaodangao","path":"/2021/04/23/L3-011 直捣黄龙 (PTA题解)-xiaodangao/","content":"题目链接：L3-011 直捣黄龙 思路：提供两种思路，一种dfs嗯搜，一种迪杰斯特拉，因为数据量小，随便过，就是麻烦 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 400+10,inf = 0x3f3f3f3f; int n,k; string s,t,a[N]; map&lt;string,int&gt;S; vector&lt;int&gt;G[N],val[N]; int pr[N]; bool st[N];int dis[N],d[N],cnt[N],f[N]; int head[N]; int ans[N],tot = 0; void dij(int t)&#123; memset(dis,0x3f,sizeof dis); dis[0] = 0;//d[0] = pr[0]; f[0] = 1; rep(i,1,n)&#123; int mx = inf,id = -1; rep(j,0,n-1)&#123; if(st[j])continue; if(dis[j]&lt;mx)&#123;mx = dis[j];id = j;&#125; &#125; st[id] = true; int sz = (int)G[id].size(); rep(j,0,sz-1)&#123; int p = G[id][j],q = val[id][j]; if(dis[p] == dis[id] + q)&#123; if(cnt[p] &lt; cnt[id] + 1)&#123; cnt[p] = cnt[id] + 1; d[p] = d[id] + pr[p]; head[p] = id; &#125; else if(cnt[p] == cnt[id] + 1)&#123; if(d[p] &lt; d[id] + pr[p])&#123;head[p] = id; &#125; d[p] = max(d[p] , d[id] + pr[p]); &#125; f[p]+=f[id]; &#125; else if(dis[p] &gt; dis[id] + q)&#123; head[p] = id; dis[p] = dis[id] + q; f[p] = f[id]; cnt[p] = cnt[id] + 1; d[p] = d[id] + pr[p]; &#125; &#125; &#125; int now = t; while(now!=0)&#123;ans[++tot] = now;now = head[now]; &#125; ans[++tot] = 0; bep(i,tot,1)&#123; cout&lt;&lt;a[ans[i]];if(i!=1)cout&lt;&lt;&quot;-&gt;&quot;; &#125; cout&lt;&lt;endl; cout&lt;&lt;f[t]&lt;&lt;&#x27; &#x27;&lt;&lt;dis[t]&lt;&lt;&#x27; &#x27;&lt;&lt;d[t]&lt;&lt;endl; //write(d[t]);pc(&#x27; &#x27;);write(f[t]);pc(&#x27; &#x27;);write(dis[t]);//pc(&#x27; &#x27;);write(cnt[t]); &#125; int tt ,high,mx = -1,mi = inf,c = 0,mx2 = -1; vector&lt;int&gt;ANS; void dfs(int id,int sum,int sum2)&#123; int sz = (int)G[id].size(); if(id == tt)&#123; if(sum &gt; mi)return ; if(sum == mi)&#123; c++; if(mx &gt; high)return; else if(mx == high)&#123; if(mx2 &gt;= sum2)return ; &#125; mx = high; mx2 = sum2; ANS.clear(); rep(i,1,high)ANS.pb(ans[i]); &#125; else &#123; c=1; mx = high;mx2 = sum2;mi = sum;ANS.clear();rep(i,1,high)ANS.pb(ans[i]); &#125; return ; &#125; st[id] = true; rep(i,0,sz-1)&#123; int p = G[id][i]; int q = val[id][i]; if(st[p])continue; ans[++high] = p; dfs(p,sum + q,sum2 + pr[p]); --high; &#125; st[id] = false; &#125; void solve()&#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;s&gt;&gt;t; rep(i,1,n-1)&#123; string u;int v; cin&gt;&gt;u&gt;&gt;v; a[i] = u; S[u] = i;pr[i] = v;d[i] = v;cnt[i] = 1; &#125;a[0] = s; S[s] = 0; rep(i,1,k)&#123; string u,v;int d; cin&gt;&gt;u&gt;&gt;v&gt;&gt;d; int idx = S[u],idy = S[v]; G[idx].pb(idy);G[idy].pb(idx); val[idx].pb(d);val[idy].pb(d); &#125; tt = S[t]; dfs(0,0,0); cout&lt;&lt;s; rep(i,0,(int)ANS.size()-1)cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;a[ANS[i]]; cout&lt;&lt;endl; cout&lt;&lt;c&lt;&lt;&#x27; &#x27;&lt;&lt;mi&lt;&lt;&#x27; &#x27;&lt;&lt;mx2&lt;&lt;endl; &#125; signed main()&#123; //puts(&quot;0&quot;); solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"L3018森森美图（优先队列BFS题解）xiaodangao","path":"/2021/04/21/L3-018 森森美图（优先队列BFS题解）-xiaodangao/","content":"题目链接：L3-018 森森美图 题意：这个题的题意很迷，大概意思就是给你一个起点一个终点，然后起点和终点连线的直线将图划分成两部分，然后分别求这两部分的起点到终点的最短路径val相加，需要注意的是，对于边权的计算，这个题边权的计算有点迷，大概就是若a-&gt;b-&gt;c均不是斜向边，那么总边权为a+b+ca+b+ca+b+c，如果b+c为斜向边，那么边权为a+b+c+(b+c)∗(2−1)a+b+c+(b+c)*(\\sqrt 2-1)a+b+c+(b+c)∗(2​−1) 思路：只要理解了题意，思路就很好写了，因为给出了起点和终点，所以用一个向量来表示一条直线，然后就是判断直线将图划分成两部分，设当前点为x，起点为s，终点为t，设向量k=x−sk = x-sk=x−s m=t−sm = t-sm=t−s判断叉积k×mk×mk×m的符号，符号相同就是在同一部分。然后就是对于两部分分别利用优先队列bfs求出图最短路径。 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define inf 1e18 #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; using namespace std; const int N = 1e2+10; const double eps = 1e-8; int n,m; int a[N][N]; struct Point&#123; int x,y; Point operator-(const Point&amp;a)const&#123; return &#123;x-a.x,y-a.y&#125;; &#125; bool operator&lt;(const Point&amp;a)const&#123; return a.x&gt;x; &#125; bool operator==(const Point&amp;a)const&#123; return a.x==x and a.y==y; &#125; &#125;; Point s,t; int cross(Point a,Point b)&#123; return a.x*b.y-a.y*b.x; &#125; Point Vector; int judge(Point a)&#123; a = a - t; if(cross(a,Vector)&gt;0)return 1; else if(cross(a,Vector)==0)return 0; return -1; &#125; priority_queue&lt;pair&lt;double ,Point&gt; &gt;q; bool st[N][N]; int l[] = &#123;1,-1,0,0,1,1,-1,-1&#125;,r[] = &#123;0,0,-1,1,1,-1,-1,1&#125;; int f; double bfs()&#123; while(!q.empty())q.pop(); q.push(&#123;-a[s.x][s.y],s&#125;); st[s.x][s.y] = true; while(!q.empty())&#123; double val = q.top().first; Point now = q.top().second; st[now.x][now.y] = true; if(now == t)return -val; q.pop(); rep(i,0,7)&#123; int idx = l[i] + now.x; int idy = r[i] + now.y; if(idx &gt;= m||idx &lt; 0||idy &gt;= n||idy &lt; 0)continue; if(st[idx][idy])continue; Point nows = &#123;idx,idy&#125;; if(nows == t)goto stk; if(judge(nows) != f)continue; stk: //st[idx][idy] = true; double k = a[idx][idy]*1.0;if(i&gt;3)k += (a[idx][idy]+a[now.x][now.y])*(sqrt(2.0)-1); //if(nows == t)&#123;return -(val-k); &#125; q.push(&#123;val-k,nows&#125;); &#125; &#125; return -1; &#125; void solve()&#123; read(n);read(m); rep(i,0,n-1)&#123; rep(j,0,m-1)read(a[j][i]); &#125; read(s.x);read(s.y);read(t.x);read(t.y); Vector = &#123;s-t&#125;; // rep(i,0,n-1)&#123; // rep(j,0,m-1)printf(&quot;%d &quot;,judge(&#123;j,i&#125;));pc(&#x27; &#x27;); // &#125; f = 1; double ans = bfs(); f = -1; //printf(&quot;%.3lf &quot;,ans); memset(st,0,sizeof st); ans += bfs(); ans -= 1.0*a[s.x][s.y];ans-=1.0*a[t.x][t.y]; printf(&quot;%.2lf &quot;,ans); &#125; signed main()&#123;solve();return 0;&#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.Playlist(Технокубок2021Финал)题解xiaodangao","path":"/2021/04/21/D. Playlist(Технокубок 2021 - Финал)题解-xiaodangao/","content":"题目链接：D. Playlist 题意：略 思路：模拟，先思考我们需要完成什么操作，因为数组是1e51e51e5级别的，所以用遍历的方式一次次的删除，太慢，所以我们需要一种数据结构，支持插入，删除，查找，遍历，且最坏时间复杂度是Θ(logn)\\Theta(logn)Θ(logn)，平衡树恰巧能够干这个活，所以我们选择用set来处理，具体思路如下，第一次遍历整个数组，将gcd(ai−1,ai)=1gcd(a_{i-1},a_i) = 1gcd(ai−1​,ai​)=1的ai−1a_{i-1}ai−1​位置的下标放入平衡树，这些都是我们需要删除的位置，因为第一次遍历之后，所有需要删除的位置都已经找到，而且该位置只会减少不会增加，接下来就是模拟，设该位置为p，他下一个位置为s，如果gcd(ap,as)=1gcd(a_p,a_s) = 1gcd(ap​,as​)=1那么将s位置永久在平衡树里删除，如果不为1，那么下一次遍历需要删除位置前，将p删除，因为p已经不能够满足删除下一个数这个操作，他和普通的数组一样了。 Code1:Code1:Code1: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define x first #define y second #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; using namespace std; const int N = 1e5+10; int _,n; set&lt;int&gt;S,G; bool st[N]; int gos[N];int a[N]; vector&lt;int&gt;ans; int q[N],tot = 0; void solve()&#123; read(_); while(_--)&#123; G.clear();ans.clear(); S.clear(); read(n); rep(i,1,n)&#123; read(a[i]); S.insert(i);//一颗平衡树存所有可用下标 st[i] = false; &#125; rep(i,2,n)&#123; if(__gcd(a[i],a[i-1]) == 1)&#123; G.insert(i-1);//另一颗平衡树存所有删除下标 &#125; &#125; if(__gcd(a[n],a[1]) == 1)G.insert(n);//循环 //删除1个 //int cnt = 0; while(true)&#123; tot = 0; bool flag = false; for(auto p:G)&#123; if(q[tot] == p)continue; if(S.size() == 0)&#123;flag = false;break;&#125;//及时退出 auto s = S.upper_bound(p);//在所有可用下标中找下一个 if(s == S.end())&#123; s = S.begin();//循环 &#125; if(__gcd(a[*s],a[p]) != 1)&#123;//如果不满足gcd为1，先将其下标存入一个数组，最后进行删除，如果现在进行删除，那么会Runtime Error q[++tot] = p; //G.erase(p); //if(G.size()==0)&#123;flag = false;break;&#125; continue; &#125; if(G.find(*s)!=G.end())&#123;//如果在另一颗平衡树中找到了他 //G.erase(*s); q[++tot] = *s; flag = true; ans.pb(*s); S.erase(*s);//if(G.size() == 0)&#123;flag = false;break;&#125; &#125; else &#123; flag = true; ans.pb(*s); S.erase(*s); &#125; &#125; rep(i,1,tot)&#123; G.erase(q[i]); &#125; if(S.empty()||flag == false||G.empty())break; &#125; write((int)ans.size());pc(&#x27; &#x27;); for(auto p:ans)write(p),pc(&#x27; &#x27;); pc(&#x27; &#x27;); &#125; &#125; signed main()&#123;solve();return 0;&#125; 利用vector进行存储 Code2:Code2:Code2: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define x first #define y second #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; using namespace std; const int N = 1e5+10; int _,n; set&lt;int&gt;S; bool st[N]; int gos[N];int a[N]; vector&lt;int&gt;G,ans; void solve()&#123; read(_); while(_--)&#123; G.clear();ans.clear(); S.clear(); read(n); rep(i,1,n)&#123; read(a[i]); S.insert(i); st[i] = false; &#125; rep(i,2,n)&#123; if(__gcd(a[i],a[i-1]) == 1)&#123; G.pb(i-1); &#125; &#125; if(__gcd(a[n],a[1]) == 1)G.pb(n); //删除1个 while(true)&#123; if(S.empty())break; bool flag = false; for(int i=0;i&lt;(int)G.size();++i)&#123; //if(G.size()&lt;) int p = G[i]; if(S.find(p) == S.end())&#123; G.erase(G.begin()+i); i--; continue; &#125; int idx = -1; if(p==*--S.end())&#123; idx = *S.begin(); &#125; else &#123; idx = *S.upper_bound(p); &#125; int k = a[idx]; if(__gcd(k,a[p]) == 1)&#123; ans.pb(idx); //printf(&quot;%d %d &quot;,k,a[p]); S.erase(idx); flag = true; &#125; else &#123; G.erase(G.begin()+i); i--; &#125; &#125; if(flag == false)break; &#125; write((int)ans.size());pc(&#x27; &#x27;); for(auto p:ans)write(p),pc(&#x27; &#x27;); pc(&#x27; &#x27;); &#125; &#125; signed main()&#123;solve();return 0;&#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"E.CheapDinner(EducationalCodeforcesRound104(RatedforDiv.2))题解xiaodangao","path":"/2021/04/20/E. Cheap Dinner(Educational Codeforces Round 104 (Rated for Div. 2))题解-xiaodangao/","content":"题目链接：E. Cheap Dinner 题意：略 思路：一开始先写了一个n2n^2n2的dpdpdp，然后发现是T，证明方法没什么问题，然后发现他虽然能连接的边数目是n2n^2n2不过不能连接的边最多也就1e51e51e5这个级别，就算一个一个遍历也可以接受，不如从第一号菜开始，sort根据第一号菜大小排序，然后对于第二号菜来说，去已排序的第一号菜中找到自己能够搭配的最小的一号菜品，因为一号菜与二号菜的不能连接的个数只有150000条，所以最坏情况下这150000个第二道菜最多需要150000+150000150000 + 150000150000+150000次的寻找，这有点类似于MexMexMex操作，然后将更新了第二道菜的贡献的数组重新排序并计算饮料对第二道菜的影响。因为边还需要用map存一下，所以复杂度Θ(nlognlogn)\\Theta(nlognlogn)Θ(nlognlogn)，可以接受。 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define x first #define y second #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e5+10,inf = 0x3f3f3f3f; int n[6],m[6],a[5][N]; vector&lt;int&gt;G[5][N]; struct node &#123; int id,data; bool operator&lt;(const node &amp;a)const&#123; return a.data&gt;data; &#125; &#125;f[N],c[N]; map&lt;pair&lt;int,int&gt;,bool&gt;S[5]; bool st[N]; void work()&#123; rep(j,1,n[1])f[j] = &#123;j,a[1][j]&#125;; sort(f+1,f+1+n[1]); int tot = n[1]; rep(i,2,4)&#123; rep(j,1,n[i])&#123; int sum = -1; st[j] = false; rep(k,1,tot)&#123; if(!S[i][&#123;j,f[k].id&#125;])&#123;sum = f[k].data; break; &#125;//continue; &#125; if(sum == -1)st[j] = true; c[j] = &#123;j,a[i][j] + sum&#125;; &#125; tot = 0; rep(j,1,n[i])&#123;if(st[j] == false) f[++tot] = c[j];&#125; if(!tot)&#123; puts(&quot;-1&quot;);return ; &#125; sort(f+1,f+1+tot); &#125; write(f[1].data);pc(&#x27; &#x27;); &#125; void solve()&#123; rep(i,1,4)read(n[i]); rep(i,1,4)&#123; rep(j,1,n[i])&#123; read(a[i][j]); &#125; &#125; rep(i,1,3)&#123; read(m[i]); rep(j,1,m[i])&#123; int u,v; read(u);read(v); S[i+1][&#123;v,u&#125;] = true; &#125; &#125; work(); &#125; signed main()&#123;solve();return 0;&#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"L3017森森快递(30分)(PTA题解)xiaodangao","path":"/2021/04/19/L3-017 森森快递 (30 分)(PTA题解)-xiaodangao/","content":"链接：L3-017 森森快递 题意：略 思路：本来想的是dfs来做，不过最后做假了，最后一想想起来一个贪心的做法，我们必须让它的范围尽可能的小，因为他只有范围尽可能的小，才能够尽量不影响别的区间，所以我按区间范围从小到大排序，再用线段树来做，成功WA在最后一个点上，正确做法是贪心，**是根据区间右端点从小到大进行排序，如果右端点相同，就进行左端点排序比较，**正确性：考虑两个区间[l,r]，[L,R]不相交还好说，互不影响，不过如果相交之后答案一定是min([L,r],min(l,L)+min(r,R))min([L,r],min(l,L)+min(r,R))min([L,r],min(l,L)+min(r,R))也就是说答案不可能比[l,r]该区间取值要大，如果答案取min(l,L)+min(r,R)还好说，这说明区间[L,r]比较宽松，但如果让区间[L,r]限制住，一定是区间[l,r]给[L,r]更多的贡献，因为只有[L,R]给的贡献尽量少的情况下，才能保证[L,R]对后面的影响较小，（后面的从未遍历过，前面的全遍历过了）。 TipsTipsTips:很显然如果需要完成这个操作我们需要知道区间最小值，还必须把某一区间的值均修改，线段树+lazy数组就能完成上述操作 Code：Code：Code： #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define x first #define y second #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 1e5+10,inf = 0x7fffffff; int n,q; int se[N]; pair&lt;int,int&gt;p[N]; int sum[N&lt;&lt;2],lazy[N&lt;&lt;2]; void build(int l,int r,int p)&#123; if(l==r)&#123; sum[p] = se[l]; return ; &#125; int mid = l + r&gt;&gt;1; build(l,mid,p&lt;&lt;1); build(mid+1,r,p&lt;&lt;1|1); sum[p] = min(sum[p&lt;&lt;1],sum[p&lt;&lt;1|1]); return ; &#125; void add(int l,int r,int s,int t,int p,int k)&#123; if(s &lt;= l and r&lt;=t)&#123; sum[p] += k; lazy[p] += k; return ; &#125; if(lazy[p] and l &lt; r)&#123;sum[p&lt;&lt;1] += lazy[p],sum[p&lt;&lt;1|1] += lazy[p],lazy[p&lt;&lt;1]+=lazy[p];lazy[p&lt;&lt;1|1]+=lazy[p]; lazy[p] = 0; &#125; int mid = l + r &gt;&gt; 1; if(s&lt;=mid)add(l,mid,s,t,p&lt;&lt;1,k); if(t&gt;mid)add(mid+1,r,s,t,p&lt;&lt;1|1,k); sum[p] = min(sum[p&lt;&lt;1],sum[p&lt;&lt;1|1]); &#125; int query(int l,int r,int s,int t,int p)&#123; if(s&lt;=l and r&lt;=t)&#123; return sum[p]; &#125; if(lazy[p] and l &lt; r)&#123;sum[p&lt;&lt;1] += lazy[p],sum[p&lt;&lt;1|1] += lazy[p],lazy[p&lt;&lt;1]+=lazy[p];lazy[p&lt;&lt;1|1]+=lazy[p]; lazy[p] = 0; &#125; int mid = l + r &gt;&gt; 1; int ans = inf; if(s&lt;=mid)ans = query(l,mid,s,t,p&lt;&lt;1); if(t&gt;mid)ans = min(query(mid+1,r,s,t,p&lt;&lt;1|1),ans); return ans; &#125; void work()&#123; ll ans = 0ll; rep(i,1,q)&#123; int l = p[i].y+1,r = p[i].x; int t = query(1,n-1,l,r,1); add(1,n-1,l,r,1,-t); ans += 1ll*t; &#125; write(ans);pc(&#x27; &#x27;); &#125; void solve()&#123; read(n);read(q); rep(i,1,n-1)&#123; read(se[i]); &#125; build(1,n-1,1); rep(i,1,q)&#123; int u,v; read(u);read(v); if(u&gt;v)swap(u,v); p[i] = &#123;v,u&#125;; &#125; sort(p+1,p+1+q); work(); &#125; signed main()&#123;solve();return 0;&#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"E.ColoringsandDominoes(EducationalCodeforcesRound107(RatedforDiv.2))题解xiaodangao","path":"/2021/04/14/E. Colorings and Dominoes(Educational Codeforces Round 107 (Rated for Div. 2))题解-xiaodangao/","content":"题目链接：E. Colorings and Dominoes 思路：我们先考虑一种最简单的情况：oooooo，我们用1代表红色，0代表蓝色，我们先计算他对于5个o的情况来说，多增加了几个，因为一个多米诺骨牌占2格，所以形如000011这种情况，这在他的上一种情况（00001）中是显然多增加了1，那么我们就看究竟有多少种这样的情况，先上图片帮助理解： 答案很显然，应该是2k−3+2k−5+...2^{k-3}+2^{k-5}+...2k−3+2k−5+...直到加到0次方为止，不过还有一点细节需要注意的就是依据上图这种方式进行计算，当数量为偶数时，总情况数需要额外再+1，当数量为奇数时，需要先减掉偶数对其的影响，这是因为111111这个对于他的上一种情况（11111）来说多增加了1种，而1111111却不会，注意我们到目前为止所说的所有情况都是对于上一种情况的增量，得到增量后我们可以很轻松的算出来总的情况。然后我们发现式子2k−3+2k−5+...2^{k-3}+2^{k-5}+...2k−3+2k−5+...是可以由上一项得到的，进而该式也能写成递推式。最后需要注意的一点是我们只计算了一条链上的ans，如果要计算该链对于总情况数的贡献，我们必须将该链的ans*2除该链之外o的个数2^{除该链之外o的个数}2除该链之外o的个数，这样才是该链对于总的贡献值。 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 3e5+10; const ll mod = 998244353; ll f[N],a[N],c[N]; void iniv()&#123; f[0] = 1; rep(i,1,N-4)f[i] = f[i-1]*2,f[i]%=mod; a[3] = 1; int d = 5; c[3] = 3;c[2] = 1; rep(i,4,N-4)&#123; if(i%2==1)&#123; a[i] = (a[i-1]-1)*2+1; &#125; else &#123; a[i] = a[i-1]*2+1; &#125; a[i] %= mod; c[i] = (c[i-1]*2)%mod + a[i]%mod; c[i] %= mod; &#125; &#125; int n,m; string str[N]; void solve()&#123; ll ans = 0ll; iniv(); read(n);read(m); rep(i,1,n)&#123; cin&gt;&gt;str[i]; &#125; int num = 0; rep(i,1,n)&#123; for(auto p:str[i])if(p == &#x27;o&#x27;)num++; &#125; rep(j,1,n) rep(i,0,m-1)&#123; int cnt = 0; ll sum = 0ll; while(i&lt;m and str[j][i] == &#x27;o&#x27;)cnt++,i++; (sum = c[cnt])%=mod; (sum *= f[num - cnt])%=mod; (ans += sum)%=mod; &#125; rep(i,0,m-1)&#123; rep(j,1,n)&#123; int cnt = 0; ll sum = 0ll; while(j&lt;=n and str[j][i] == &#x27;o&#x27;)cnt++,j++; sum = c[cnt]; (sum *= f[num-cnt])%=mod; (ans += sum)%=mod; &#125; &#125; write(ans%mod);pc(&#x27; &#x27;); &#125; signed main() &#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"C.PekoraandTrampoline(CodeforcesGlobalRound13)题解xiaodangao","path":"/2021/04/10/C. Pekora and Trampoline(Codeforces Global Round 13)题解-xiaodangao/","content":"题目链接：C. Pekora and Trampoline 思路：差分，经过仔细思考可以发现，最优解一定是都在1这个位置进行跳跃，因为假设1这个位置上的a[1]=1，那么他会跳到2，也就是具有传递性，直到跳到一个value不为1的地方，这和一开始就在该位置跳是一样的。证明了这个之后，我们进一步思考可以发现，i这个位置，可以对后面[i+2,min(a[i]+i,n)]产生影响，产生的影响是后面这些用跳的次数-1，然后再根据a[i]=1的传递性，如果位置j的value已经降为了1，那么前面对他的贡献可以继续延伸到j+1，对于每一个数对于后面产生的影响，我们可以用一个差分数组Θ(1)\\Theta(1)Θ(1)的完成 Code:Code:Code: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define x first #define y second #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 5e3+10; int _,n; int a[N],sum[N]; void work(int now,int l)&#123; if(now&lt;l)return ; int y = min(now,n); int x = min(l,n); if(l &gt; n)x = n+1; sum[x]++; sum[y+1]--; &#125; void solve()&#123; read(_); while(_--)&#123; memset(sum,0,sizeof sum); read(n); rep(i,1,n)&#123; read(a[i]); &#125; rep(i,1,n)&#123; work(a[i]+i,i+2); &#125; int now = 0; ll ans = 0; rep(i,1,n)&#123; now+=sum[i]; //int p = now; if(a[i] - now&lt; 1)&#123; sum[i+1] += now - a[i] + 1; sum[i+2] -= now - a[i] + 1; a[i] = 0; &#125; a[i]-=now; a[i]--; a[i] = max(a[i],0); ans+=(ll)a[i]; //write(max(a[i],0));pc(&#x27; &#x27;); &#125; write(ans);pc(&#x27; &#x27;); &#125; &#125; signed main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.ZookeeperandTheInfiniteZoo（CodeforcesGlobalRound13）题解xiaodangao","path":"/2021/04/10/D. Zookeeper and The Infinite Zoo（ Codeforces Global Round 13）题解-xiaodangao/","content":"题目链接：D. Zookeeper and The Infinite Zoo 思路： 我们在图中展现11011-&gt;10110100有边，图中显示的是让11011的第一个1与10110100中第一个1对齐的操作，如此可见，设a到b有边，那么a的二进制表示的第一个1必须小于等于b的二进制表示的第一个1的位置，换句话说，在左边的1能够进行若干次操作移动到右边，并且不影响a在该位之后的位置，所以这个结论再进行总结就是若a到b有边，当且仅当a对于每一位1的前缀和总是大于等于b的； Coding:Coding:Coding: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define x first #define y second #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;'0'||c&gt;'9';c=ch())if(c=='-')f=-f; for(x=0;c&gt;='0'&amp;&amp;c&lt;='9';c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc('-'),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+'0'); &#125; const int N = 10000+10; int mex[4] = &#123;0,2,3,1&#125;; int n; int top[110][110]; pair&lt;int,int&gt;idx,idy; int gos(int a,int b)&#123; rep(i,1,3)&#123; if(i!=a&amp;&amp;i!=b)return i; &#125; return 1; &#125; int sum1[44],sum2[44]; bool check(int a,int b)&#123; memset(sum1,0,sizeof sum1); memset(sum2,0,sizeof sum2); if(a == b)return true; else if(b&lt;a)return false; int p = b - a; rep(i,0,29)&#123; if((a&gt;&gt;i)&amp;1)sum1[i]++; if((b&gt;&gt;i)&amp;1)sum2[i]++; if(i!=0)&#123; sum1[i]+=sum1[i-1]; sum2[i]+=sum2[i-1]; &#125; if(sum2[i]&gt;sum1[i])return false; &#125; return true; &#125; void solve()&#123; read(n); int cnt = 0; while(n--)&#123; cnt++; int u,v; read(u);read(v); if(check(u,v))puts(&quot;YEs&quot;); else puts(&quot;NO&quot;); //stk:; &#125; &#125; signed main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"D.3ColoringCodeforcesRound#712(Div.2)（题解）xiaodangao","path":"/2021/04/08/D. 3-Coloring Codeforces Round #712 (Div. 2)（题解）-xiaodangao/","content":"题目链接：D. 3-Coloring 题意：略； 思路：和答案思路不一样，开始设两个对角线一个是从（1,1）开始，另一个是从（2,1）开始然后开始处理，这两个对角线一个是奇数行的对角线，一个是偶数行的对角线，比方说一个对角线(2,1),(4,1),(6,1)是偶数行对角线，然后保证该对角线上是同一种颜色，如果能染该种颜色就染该种，否则肯定能染另一条对角线，然后直到有对角线遍历完，标记一下该对角线，比方说剩下一条奇数行对角线，那么这条线只要不染偶数行的颜色，就一定可以。复杂度Θ(n2)\\Theta(n^2)Θ(n2) Coding:Coding:Coding: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define x first #define y second #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 10000+10; int mex[4] = &#123;0,2,3,1&#125;; int n; int top[110][110]; pair&lt;int,int&gt;idx,idy; int gos(int a,int b)&#123; rep(i,1,3)&#123; if(i!=a&amp;&amp;i!=b)return i; &#125; return 1; &#125; void solve()&#123; scanf(&quot;%d&quot;,&amp;n); idx = &#123;2,0&#125;;idy = &#123;3,0&#125;; rep(i,1,n+1)&#123; i++; top[i][0] = 1; &#125; rep(i,2,n+1)&#123; i++; top[i][0] = 2; &#125; int flag = 0;int a = top[idx.x][idx.y],b = top[idy.x][idy.y]; rep(test,1,n*n)&#123; int f; scanf(&quot;%d&quot;,&amp;f); int l , r , k; if(flag == 1)goto stk; else if(flag == 2)goto stp; if(f == a)&#123; stp: idy.x--;idy.y++; if(idy.x&lt;1||idy.y&gt;n)&#123; idy.x = idy.x + idy.y + 1; idy.y = 1;//(6,1) if(idy.x&gt;=2*n)&#123;flag = 1;goto stk; &#125; if(idy.x&gt;n)idy.y = idy.y + idy.x - n,idy.x = n; &#125; top[idy.x][idy.y] = b; k = b; l = idy.x; r = idy.y; if(flag == 2)&#123; k = gos(f,a); &#125; top[idy.x][idy.y] = k; &#125; else &#123; stk: idx.x--;idx.y++; if(idx.x&lt;1||idx.y&gt;n)&#123; idx.x = idx.x + idx.y + 1; idx.y = 1; if(idx.x&gt;=2*n)&#123;flag = 2;goto stp; &#125; if(idx.x&gt;n)idx.y = idx.y + idx.x - n,idx.x = n; &#125; //printf(&quot;b:%d %d &quot;,idy.x,idy.y); top[idx.x][idx.y] = a; k = a; l = idx.x; r = idx.y; if(flag == 1)&#123; k = gos(f,b); &#125; if(flag)top[idx.x][idx.y] = k; &#125; printf(&quot;%d %d %d &quot;,k,l,r); fflush(stdout);//交互性加上这句话 &#125; &#125; signed main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"C.KbeautifulStringsCodeforcesRound#705(Div.2)题解xiaodangao","path":"/2021/04/08/C. K-beautiful Strings Codeforces Round #705 (Div. 2)题解-xiaodangao/","content":"题目链接：C. K-beautiful Strings 题意：略 思路：本来这题我的思路是错误的，当时也考虑贪心的做法，但想法还是不完备，参考了大神的做法之后写出来了一份代码，方法是对于从n-1到0的每一位进行考虑，因为题目说的是目标串要大于等于当前串，于是我们肯定只从后往前改最少位才能获得最优解，如果还不理解，你可以将他看成是一个26进制数，肯定是最好不动高位数才能满足大于等于且“最小”这个操作，然后具体思路是，我们可以维护一个数，该数的意义是当前至少需要多少个字母才能把当前位置之前的字母凑齐，然后我们不断维护该数，当该数小于等于该位置到尾部位置时就可以退出进行赋值。复杂度Θ(26∗n)\\Theta(26*n)Θ(26∗n) Coding:Coding:Coding: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(auto i=a;i&lt;=b;++i) #define bep(i,a,b) for(auto i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e5+10; int a[N]; char str[N],c[N]; int cnt[33],cnt2[33]; bool st[N],vis[33]; void solve()&#123; int n,k,_; read(_); while(_--)&#123; memset(cnt,0,sizeof cnt); read(n);read(k); scanf(&quot;%s&quot;,str); if(n%k)&#123; puts(&quot;-1&quot;);continue; &#125; rep(i,0,n-1)&#123; cnt[str[i] - &#x27;a&#x27;]++; &#125; int sum = 0; rep(i,0,25)&#123; sum += (k-cnt[i]%k)%k; &#125; if(sum == 0)&#123; puts(str); goto stk; &#125; bep(i,n-1,0)&#123; int dis = n - i; sum -= (k - cnt[str[i] - &#x27;a&#x27;]%k)%k; cnt[str[i] - &#x27;a&#x27;]--; sum += (k - cnt[str[i] - &#x27;a&#x27;]%k)%k; //printf(&quot;%d %d &quot;,i,sum); //if(sum &gt; dis)continue; int now = i,id = -1; rep(j,str[i]-&#x27;a&#x27;+1,25)&#123; int x = sum; sum -= (k - cnt[j]%k)%k; cnt[j]++; sum += (k - cnt[j]%k)%k; //printf(&quot;%d:%d %d &quot;,i,j,sum); if(sum&lt;=dis-1)&#123; //cnt[j]++; id = j;break; &#125; else sum = x,cnt[j]--; &#125; if(id!=-1)&#123; str[i] = id + &#x27;a&#x27;; int h = n-1;//cnt[0] = 888888; rep(j,0,25)cnt2[j] = (k - cnt[j]%k)%k; cnt2[0] = 888888; while(h&gt;=i+1)&#123; //bool flag = false; bep(j,25,0)if(cnt2[j])&#123;str[h] = j+&#x27;a&#x27;;cnt2[j]--; break; &#125;h--; &#125; puts(str); goto stk; &#125; &#125; //puts(&quot;-2&quot;); stk:; &#125; &#125; signed main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"POJ.3585AccumulationDegree(树型DP)xiaodangao","path":"/2021/03/29/POJ.3585 Accumulation Degree(树型DP)-xiaodangao/","content":"题目链接：Accumulation Degree 题意：略 思路：利用一次dfs，可求出一点为源点的答案，我们将这一点设为x点，下一步dfs时，可以利用x点的答案推出他所有儿子节点的答案，因为x节点的答案已经知道，然后对于他每一个儿子节点（y），我们上一步dfs求出来他到除了x点以外的节点的答案（即他这棵关于x子树的答案），那么考虑该儿子节点作为源点的答案，答案为x节点的其他子树的贡献与边（x，y）的边权的取min再加上该节点子树的答案。不理解的同学可以画一棵树自己体会一下这个过程。 Coding:Coding:Coding: /************************************************************************* &gt; File Name: 3585.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2021年03月29日 星期一 16时10分16秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 2e5+10; //#define int long long int T; int n,deg[N]; int f[N],ans[N]; vector&lt;int&gt;G[N],val[N]; bool st[N]; void dfs(int id)&#123; if(st[id])return ; st[id] = true; // write(id);pc(&#x27; &#x27;); rep(i,0,(int)G[id].size()-1)&#123; int p = G[id][i];int v = val[id][i]; if(st[p])continue; dfs(p); if(deg[p] != 1) f[id] += min(v,f[p]); else f[id] += v; &#125; &#125; int ANS = 0; void getans(int id)&#123; if(st[id])return; st[id] = true; rep(i,0,(int)G[id].size()-1)&#123; int p = G[id][i],v = val[id][i]; if(st[p])continue; int t = ans[id] - min(f[p],v); if(deg[id] == 1)t = v; int k = min(t,v); ans[p] = f[p] + k; if(deg[p] == 1)ans[p] = min(v,ans[p]); ANS = max(ANS,ans[p]); &#125; rep(i,0,(int)G[id].size()-1)&#123; int p = G[id][i]; getans(p); &#125; &#125; void init()&#123; rep(i,1,n)G[i].clear(),val[i].clear(); memset(st,0,sizeof st); memset(f,0,sizeof f); memset(ans,0,sizeof ans); memset(deg,0,sizeof deg); &#125; void solve()&#123; read(T); while(T--)&#123; read(n); ANS = 0; init(); rep(i,1,n-1)&#123; int u,v,w; read(u);read(v);read(w); G[u].pb(v); G[v].pb(u); val[u].pb(w); val[v].pb(w); deg[u]++;deg[v]++; &#125; dfs(1); memset(st,0,sizeof st); ans[1] = f[1]; ANS = ans[1]; getans(1); write(ANS);pc(&#x27; &#x27;); &#125; &#125; signed main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"Acwing.10有依赖的背包问题(树型DP,分组背包)xiaodangao","path":"/2021/03/27/Acwing.10 有依赖的背包问题(树型DP,分组背包)-xiaodangao/","content":"题目链接：Acwing.10 有依赖的背包问题(树型DP,分组背包) 思路：模板题，从上到下考虑每一个节点，数组f[i][j]第一维表示选择第i个节点，第二维表示体积，然后我们对于一颗子树和他的若干儿子节点这样想，第一步，处理他的儿子节点，由于对于他每一个儿子节点，他只能选择一个体积，所以这就变成了每一个儿子节点为一组的分组背包问题，对于n个儿子节点，分组01背包求Max，最后需要注意的是，由于是必须选择它本身，所以我们f[i][j]最后要加上个w[i]; Coding:Coding:Coding: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 110; int n,V; int v[N],w[N]; int f[N][N]; vector&lt;int&gt;G[N]; void dfs(int id,int t)&#123; for(auto p:G[id])&#123; int maxn = t - v[id]; dfs(p,maxn); bep(i,maxn,0)&#123; rep(j,0,i)&#123; f[id][i] = max(f[id][i-j] + f[p][j],f[id][i]); &#125; &#125; &#125; bep(i,t,v[id])f[id][i] = f[id][i-v[id]] + w[id]; rep(i,0,v[id]-1)f[id][i] = 0; &#125; void solve()&#123; read(n);read(V); rep(i,1,n)&#123; int x,y,z; read(x);read(y);read(z); if(z == -1)&#123; G[0].pb(i); &#125; else G[z].pb(i); v[i] = x;w[i] = y; &#125; dfs(0,V); write(f[0][V]);pc(&#x27; &#x27;); &#125; signed main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"Acwing.284金字塔(区间DP)题解xiaodangao","path":"/2021/03/18/Acwing.284 金字塔(区间DP)题解-xiaodangao/","content":"虽然探索金字塔是极其老套的剧情，但是有一队探险家还是到了某金字塔脚下。 经过多年的研究，科学家对这座金字塔的内部结构已经有所了解。 首先，金字塔由若干房间组成，房间之间连有通道。 如果把房间看作节点，通道看作边的话，整个金字塔呈现一个有根树结构，节点的子树之间有序，金字塔有唯一的一个入口通向树根。 并且，每个房间的墙壁都涂有若干种颜色的一种。 探险队员打算进一步了解金字塔的结构，为此，他们使用了一种特殊设计的机器人。 这种机器人会从入口进入金字塔，之后对金字塔进行深度优先遍历。 机器人每进入一个房间（无论是第一次进入还是返回），都会记录这个房间的颜色。 最后，机器人会从入口退出金字塔。 显然，机器人会访问每个房间至少一次，并且穿越每条通道恰好两次（两个方向各一次）， 然后，机器人会得到一个颜色序列。 但是，探险队员发现这个颜色序列并不能唯一确定金字塔的结构。 现在他们想请你帮助他们计算，对于一个给定的颜色序列，有多少种可能的结构会得到这个序列。 因为结果可能会非常大，你只需要输出答案对10910910^9 取模之后的值。 输入格式 输入仅一行，包含一个字符串 SSS，长度不超过 300300300，表示机器人得到的颜色序列。 输出格式 输出一个整数表示答案。 输入样例： ABABABA 输出样例： 5 思路：本来的思路是考虑到它的每一个子树均有A(子树1)A(子树2)A...A(子树n)AA(子树1)A(子树2)A...A(子树n)AA(子树1)A(子树2)A...A(子树n)A这种结构，所以当时的思路是对于一个区间，找到有多少个和他相同的节点，然后递归得到它每个子树的数量，单位区间设为每两个相同节点间，区间长度从2开始DP得到最后答案数量，最后一步是判断它本身只有一颗子树的情况，最后++；这种情况实现比较复杂，很难调试，而且复杂度较高，看了答案之后发现大佬另外一种思路。 思路2：对于每一个区间来说，枚举它第一棵合法子树，因为对于区间来说，可以根据第一棵子树的模样，不重不漏的将区间划分成很多子集，因此只需要每句第一棵子树，再加上记忆化就可以解决了 Coding：Coding：Coding： /************************************************************************* &gt; File Name: 284.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2021年03月16日 星期二 15时06分17秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; #define int long long const int N = 3e2+10,mod = 1e9; char str[N]; int f[N][N]; int dfs(int l,int r)&#123; if(r&lt;l)return 0; if(l == r)return 1; if(f[l][r]!=-1)return f[l][r]; if(str[l] != str[r])return 0; f[l][r] = 0; rep(k,l+2,r)&#123; f[l][r] += dfs(l+1,k-1)*dfs(k,r); f[l][r]%=mod; &#125; return f[l][r]; &#125; void solve()&#123; memset(f,-1,sizeof f); scanf(&quot;%s&quot;,str); int lens = strlen(str); //rep(i,0,lens-1)f[i][i] = 1; int ans = dfs(0,lens-1); write(ans);pc(&#x27; &#x27;); &#125; signed main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"KPhDmath(数学)题解xiaodangao","path":"/2021/03/18/K - PhD math (数学)题解-xiaodangao/","content":"K. PhD mathtime limit per test8 secondsmemory limit per test1024 megabytesinputstandard inputoutputstandard outputJohnny is a brilliant mathematics student. He loves mathematics since he was a child, now he is working on his PhD thesis. He faces a small mathematical problem, he has a n digit integer number (let us call it s) , he wants to find how many substring of s are divisible by a prime number p.His supervisor professor is on vacation now, so can you play his role and help him with that?InputThe first line contains the number of test cases T. Each of the next T lines represents a test case. For each test case you will be given 4 numbers: 1 ≤ a, b ≤ 1018, 1 ≤ n ≤ 106, 2 ≤ p &lt; 200. Where a &lt; b. s is not directly given in the input, you have to calculate it from a and b as follows: s is the first n digits from the decimal representation of a / b (treat a / b decimal representation as it has an infinite digits and just take the first n digits from the left)OutputFor each test case you should print one line containing the number of substrings of s that can be divided by p without remainder.ExamplesInputCopy32 4 3 52 4 2 52 4 1 5OutputCopy631NoteFor the first test case in the sample, a=2, b=4, n=3 and p=5. So s=500 and there are 6 substrings that are divided by p which are: 5, 0, 0, 50, 00, 500. 题意：给你两个数a，b，a/b得到一个小于1的数，这个小数的前n位组成一个字符串，求这个字符串有多少子串对一个质数P取模答案为0； 思路：注意到质数P的范围是[1,200][1,200][1,200]，因此我们可以利用这个质数范围，维护的集合是对于以i结尾的子串，有多少串取模答案为j注意到设一个以i-1为结尾的子串所代表的数字是t，则循环到i时该子串变为t∗10+arr[i]t*10 + arr[i]t∗10+arr[i]我们对他进行取模运算，就能得到答案，进一步思考可以得出，因为 t * 10 + arr[i] (mod p) = ((t%p)*(10%p))%p + arr[i]%p (mod p) ，这个式子说明对于每一个有相同余数的子串，在第i轮时余数相同所以我们只需要存储t%p，也就是说存储子串模p之后的数量，并且每次更新一下，就能得到最后答案 Coding:Coding:Coding: #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; //#define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) #define ll long long using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; //#define int ull //#define ll ull const int N = 1e6+10; int arr[N],n,p; void doit(ll a,ll b)&#123; a*=10; rep(i,1,n)&#123; int k = a/b; arr[i] = k; a %= b; a *= 10; &#125; &#125; ll cnt[300],cnt2[300]; void solve()&#123; int _; read(_); while(_--)&#123; memset(cnt,0,sizeof cnt); memset(cnt2,0,sizeof cnt2); ll a,b; read(a);read(b);read(n);read(p); doit(a,b); ll ans = 0; rep(i,1,n)&#123; //printf(&quot;%d &quot;,arr[i]); int z = arr[i]; z%=p; int k = p-z; ll sum = 0; memset(cnt,0,sizeof cnt); rep(j,0,p-1)&#123; int v = ((j*10)%p+z%p)%p; //int c = (j*10)%p; //printf(&quot;%llu-%llu &quot;,v,j); cnt[v] += cnt2[j]; //cnt[v] += cnt2[c]; &#125; //pc(&#x27; &#x27;); //printf(&quot;%llu &quot;,z); cnt[z]++; sum = cnt[0]; ans += sum; rep(j,0,p-1)cnt2[j] = cnt[j]; //puts(&quot;&quot;); &#125; //pc(&#x27; &#x27;); write(ans);pc(&#x27; &#x27;); &#125; &#125; signed main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"poj.1179Polygon(区间DP)题解xiaodangao","path":"/2021/03/15/poj.1179 Polygon(区间DP)题解-xiaodangao/","content":"题目链接：http://poj.org/problem?id=1179 题意：略 思路：通过上一个石子合并的区间DP问题给了我思路(不熟悉ororor没写过的同学可以去刷Acwing.282Acwing.282Acwing.282)，石子合并问题中两个相邻石子合并的valuevaluevalue是sumsumsum，而本题的valuevaluevalue是AopBA op BAopB，具体说一下DP方法，第一层枚举区间长度，就类似于一个定长小方块的移动，每次均把相邻的长度为LenLenLen的小方块中的答案处理，含义是指在这个区间内子问题的答案，然后就涉及到状态的转移，因为我们第一层枚举的是长度，所以在我们处理Len=iLen = iLen=i时，对于每一个Len∈[1,i−1]Len \\in [1,i-1]Len∈[1,i−1]我们均得到了答案，对于Len=iLen = iLen=i我们从下标为1开始枚举，每次该区间的答案是由f[1][k]opf[k+1][i+1−1](k∈[1,i+1−1])f[1][k] op f[k+1][i+1-1] (k \\in [1,i+1-1])f[1][k]opf[k+1][i+1−1](k∈[1,i+1−1])进行得到，区间补充不漏，值得补充的是最外层还要加一个偏移量，因为要枚举第一条删掉的边，这样复杂度为O(n4)O(n^4)O(n4)，进一步思考可以得到，创造一个长度为2∗Len2*Len2∗Len的数组，枚举的长度变为2∗Len2*Len2∗Len，枚举一遍便可以得到答案，复杂度为O(n3)O(n^3)O(n3)，以下是我O(n4)O(n^4)O(n4)的做法 Coding:Coding:Coding: /************************************************************************* &gt; File Name: 283.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2021年03月15日 星期一 18时26分21秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 50+10; int arr[N],op[N]; int f[N][N]; int v; int n; int cal(int i)&#123; return (v+i)%n; &#125; int uf[N][N]; vector&lt;int&gt;ans; void solve()&#123; read(n); rep(i,0,n-1)&#123; char s[3]; scanf(&quot;%s&quot;,s); read(arr[i]); if(s[0] == &#x27;t&#x27;)op[i] = 1; &#125; int mx = -999999; rep(dlt,0,n-1)&#123; v = dlt; memset(f,0xcf,sizeof f); memset(uf,0x3f,sizeof f); rep(i,1,n)f[cal(i)][cal(i)] = arr[cal(i)],uf[cal(i)][cal(i)] = arr[cal(i)]; rep(lens,2,n)&#123; rep(t,0,n-lens)&#123; int j = t+lens-1; rep(k,t,j-1)&#123; //f[cal(t)][cal(j)] = max(f[cal(t)][cal(j)],op[cal(k+1)] == 0?f[cal(t)][cal(k)]*f[cal(k+1)][cal(j)]:f[cal(t)][cal(k)] + f[cal(k+1)][cal(j)]); int h = f[cal(t)][cal(j)],a = f[cal(t)][cal(k)],b = f[cal(k+1)][cal(j)],a1 = uf[cal(t)][cal(k)],b1 = uf[cal(k+1)][cal(j)]; int h2 = uf[cal(t)][cal(j)]; if(op[cal(k+1)] == 1)&#123; h = max(h,a+b); h2 = min(h2,a1 + b1); &#125; else &#123; h = max(h,a*b); h = max(h,a1*b); h = max(h,a*b1); h = max(h,a1*b1); h2 = min(h2,a*b); h2 = min(h2,a*b1); h2 = min(h2,a1*b); h2 = min(h2,a1*b1); &#125; f[cal(t)][cal(j)] = h; uf[cal(t)][cal(j)] = h2; &#125; &#125; &#125; if(mx &lt; f[cal(0)][cal(n-1)])&#123; mx = f[cal(0)][cal(n-1)]; ans.clear(); ans.pb(dlt+1); &#125; else if(mx == f[cal(0)][cal(n-1)])&#123; mx = f[cal(0)][cal(n-1)]; ans.pb(dlt+1); &#125; //mx = max(mx,f[cal(0)][cal(n-1)]); &#125; write(mx); pc(&#x27; &#x27;); rep(i,0,(int)ans.size()-1)&#123; int p = ans[i]; write(p); if(ans.size()-1 == i)pc(&#x27; &#x27;); else pc(&#x27; &#x27;); &#125; &#125; signed main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"Acwing199.余数之和（数学+思维）xiaodangao","path":"/2020/12/21/Acwing199. 余数之和（数学+思维）-xiaodangao/","content":"给出正整数n和k，计算j(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n的值。 例如j(5, 3)=3 mod 1 + 3 mod 2 + 3 mod 3 + 3 mod 4 + 3 mod 5=0+1+0+3+3=7。 输入格式 输入仅一行，包含两个整数n, k。 输出格式 输出仅一行，即j(n, k)。 数据范围 1≤n,k≤1091≤n,k≤1091 \\le n,k \\le 10^9 输入样例： 5 3 输出样例： 7 思路：看了大神的代码才学会的，方法是分块: j(n,k)=∑i=1n(k−⌊ki⌋∗i)=n∗k−∑i=1n(⌊ki⌋∗i)j(n,k) = \\displaystyle\\sum_{i=1}^n(k- \\lfloor \\frac{k}{i} \\rfloor * i) = n*k - \\sum_{i=1}^n(\\lfloor \\frac{k}{i} \\rfloor * i)j(n,k)=i=1∑n​(k−⌊ik​⌋∗i)=n∗k−i=1∑n​(⌊ik​⌋∗i) 然后我们根据式子可以发现，难点在于⌊ki⌋\\lfloor \\frac{k}{i} \\rfloor⌊ik​⌋ 的求法，可以看出来⌊ki⌋\\lfloor \\frac{k}{i} \\rfloor⌊ik​⌋的值在i变化时可能不会发生改变，所以我们思考是否能够通过求⌊ki⌋\\lfloor \\frac{k}{i} \\rfloor⌊ik​⌋ 的变化范围进而求值。想到这一步必须先证明⌊ki⌋\\lfloor \\frac{k}{i} \\rfloor⌊ik​⌋ 中的值的确是很有限的，与nnn不在一个量级上，事实证明确实是这样的，考虑iii的取值从1−k1-\\sqrt k1−k​的情况，因为该段有k\\sqrt kk​个取值，所以在该段的⌊ki⌋\\lfloor \\frac{k}{i} \\rfloor⌊ik​⌋最多有k\\sqrt kk​个取值，然后考虑k−k\\sqrt k-kk​−k的情况，观察⌊ki⌋\\lfloor \\frac{k}{i} \\rfloor⌊ik​⌋发现当iii取k−&gt;k\\sqrt k-&gt;kk​−&gt;k时⌊ki⌋≤k\\lfloor \\frac{k}{i} \\rfloor \\leq \\sqrt k⌊ik​⌋≤k​那就证明了在k−&gt;k\\sqrt k-&gt;kk​−&gt;k段上，也最多仅有k\\sqrt kk​个取值； 然后我们现在就是求对于⌊ki⌋\\lfloor \\frac{k}{i} \\rfloor⌊ik​⌋的每一个取值的上下界，设一个取值的下界是xxx那么上界会是什么呢？ 设a∗b=ka*b = ka∗b=k（左边不一定是整数）观察到我们如果想让bbb的取值不发生变化，那么我们取⌊b⌋\\lfloor b \\rfloor⌊b⌋能得到最大的aaa，这里的思路也是这样，上界取⌊k/⌊k/x⌋⌋\\lfloor k/\\lfloor k/x \\rfloor \\rfloor⌊k/⌊k/x⌋⌋这里⌊k/b⌋\\lfloor k/b \\rfloor⌊k/b⌋就代表这个⌊b⌋\\lfloor b \\rfloor⌊b⌋的取值； 随后再加一个等差数列求和公式； Code:Code:Code: /************************************************************************* &gt; File Name: Acwing.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2020年12月21日 星期一 10时41分06秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) using namespace std; ll n,k; void solve()&#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); ll ans = n*k,r; for(ll l=1;l&lt;=n;l = r+1)&#123; if(k/l == 0)break; r = min(n,k/(k/l)); ll p = k/l; ans -= p*(r-l+1)*(l+r)/2; &#125; printf(&quot;%lld &quot;,ans); &#125; int main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"AcWing198.反素数（数学+DFS）xiaodangao","path":"/2020/12/21/AcWing198. 反素数（数学+DFS）-xiaodangao/","content":"对于任何正整数x，其约数的个数记作g(x)，例如g(1)=1、g(6)=4。 如果某个正整数x满足：对于任意的小于x的正整数 i，都有g(x)&gt;g(i) ，则称x为反素数。 例如，整数1，2，4，6等都是反素数。 现在给定一个数N，请求出不超过N的最大的反素数。 输入格式 一个正整数N。 输出格式 一个整数，表示不超过N的最大反素数。 数据范围 1≤N≤2∗1091≤N≤2∗1091 \\le N \\le 2*10^9 输入样例： 1000 输出样例： 840 思考这个题的时候，我发现了反素数的一系列质因数必须能分解成2k1,3k2...2^{k1},3^{k2}...2k1,3k2...形如这种的从最小素数开始且连续且指数k1,k2k1,k2k1,k2非严格单调递增的，然后；但是当时没有考虑到的一点是从最小素数开始连续的10项素数的乘积已经大于2∗1092*10^92∗109，并且当时并没有想到搜索，今后不能犯经验主义错误，全面考虑。 思路：发现这一条性质之后，运用dfs枚举每一个质因数的个数； Code:Code:Code: /************************************************************************* &gt; File Name: acwing.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2020年12月20日 星期日 20时32分09秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) using namespace std; const ll N = 100,inf = 2e9+10; ll n; bool st[N*10]; ll prime[N],tot; void iniv()&#123; for(ll i=2;i&lt;=N;++i)&#123; if(!st[i])&#123; prime[++tot] = i; for(ll j=i*i;j&lt;=N;j+=i)st[j] = true; &#125; &#125; &#125; ll work[N],ans,mx; void dfs(ll now,ll x,ll id)&#123; ll cnt = 0; while(cnt &lt; now)&#123;x*=prime[id],cnt++;if(x&gt;=inf)&#123;now = cnt;break; &#125; &#125; bool flag = true; for(ll i=now;i&gt;=1;--i)&#123; if(x &lt;= n&amp;&amp;prime[id+1]&lt;=31)&#123; work[id] = i; ll sum = 1;dfs(i,x,id+1); for(ll k=1;k&lt;=id;++k)sum*=work[k]+1; if(sum&gt;mx&amp;&amp;x&lt;=n)ans = x,mx = sum; else if(sum==mx&amp;&amp;ans&gt;x)ans = x; &#125; x /= prime[id] ; &#125; &#125; void solve()&#123; scanf(&quot;%lld&quot;,&amp;n); dfs(31,1,1); printf(&quot;%lld &quot;,ans); &#125; int main()&#123; iniv(); solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"Acwing.197.阶乘分解(题解)xiaodangao","path":"/2020/12/18/Acwing.197. 阶乘分解(题解)-xiaodangao/","content":"给定整数 N ，试把阶乘 N! 分解质因数，按照算术基本定理的形式输出分解结果中的 pipip_i 和 cicic_i 即可。 输入格式 一个整数N。 输出格式 N! 分解质因数后的结果，共若干行，每行一对pi,cipi,cip_i, c_i，表示含有pciipicip_i^{c_i}项。按照pipip_i从小到大的顺序输出。 数据范围 1≤N≤1061≤N≤1061 \\le N \\le 10^6 输入样例： 5 输出样例： 2 3 3 1 5 1 样例解释 5!=120=23∗3∗55!=120=23∗3∗55! = 120 = 2^3 * 3 * 5 水题，分解质因数，然后看到一个不一样的做法，是真的惊艳到我了，或许以后能够借鉴他的思路，换个角度思考问题。 思路，先用筛子筛出10610^6106内的素数，然后考虑nnn这个数，对于每个素数xxx而言，nnn是xxx的n/xn/xn/x倍，也就是说，对于小于等于xxx的数，形如x,2x,3x...kxx,2x,3x...kxx,2x,3x...kx这种形式有⌊nx⌋\\lfloor \\frac{n}{x} \\rfloor⌊xn​⌋个，那么很容易的得到，对于xxx而言，有⌊nx⌋\\lfloor \\frac{n}{x} \\rfloor⌊xn​⌋个数是xxx的倍数，即能被xxx整除；然后我们将x∗xx*xx∗x与上面的含义一样，意为计算nnn有几个x∗xx*xx∗x的倍数，这一步操作我们将n/xn/xn/x，含义一样。 Code:Code:Code: #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e6+10; int n,prime[N],tot; bool st[N]; void init()&#123; for(int i=2;i&lt;=N;++i)&#123; if(!st[i])&#123; prime[++tot] = i; if(i&gt;=10000)continue; for(int j=i*i;j&lt;=N;j+=i)st[j] = true; &#125; &#125; &#125; int main()&#123; init(); scanf(&quot;%d&quot;,&amp;n); for(int i=1;prime[i]&lt;=n;++i)&#123; int now = n,ans = 0; while(now)&#123; ans+=(now/prime[i]); now/=prime[i]; &#125; printf(&quot;%d %d &quot;,prime[i],ans); &#125; return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"JumpingMachine(集合选数问题)xiaodangao","path":"/2020/12/16/Jumping Machine(集合选数问题)-xiaodangao/","content":"Jumping Machine Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 512 megabytes Young inventor has created a new jumping machine. In order to test it, he brought it to the testing polygon. The polygon is an infinite square grid. Initially, the machine is located in the cell (0, 0). The machine has n springs, the i-th spring has the force of li and allows the machine to jump li cells up or li cells to the right. Therefore this spring allows the machine to get from cell (x, y) either to cell (x + li, y), or to cell (x, y + li). After jumping, the spring is thrown back and cannot be reused. The machine can use the springs in any order. During the tests the cells, that the machine will fly over, will be stained with machine oil. In order not to clean the grid after himself, the inventor has decided to put a protective mat on each cell the machine could potentially fly over. Now the inventor is wondering how many protective mats he needs to bring to the test with him. Input The first line of input contains n — the number of springs that the machine has (1 ≤ n ≤ 100). The second line contains n integers li — the springs forces (li ≥ 1; 1 ≤ l1 + l2 + · · · + ln ≤ 106). Output Output a single integer: the number of mats that inventor needs to bring. Example standard input standard output 2 4 2 22 Explanation All the cells that can get dirty when the machine jumps in the example test are colored orange one the figure below 思路：感觉有点像dpdpdp，首先发现所有终点(x,y),x+y(x,y),x+y(x,y),x+y为定值，然后发现我们可以定一个xxx增加的长度，当然这个长度是属于arriarr_iarri​的，那么yyy增加的长度就是sum−xsum-xsum−x，然后我们不用考虑先上移再右移再上移这种情况，我们只需要枚举出xxx增加的长度，即可，这么做显然是正确的，因为我们枚举了所有可能到达的xxx长度，相应的yyy的长度也已经完全了，然后分别做出先延xxx走到头，再延yyy走到头，和先延yyy走到头，再延xxx走到头，可以发现构成一个矩形，随着xxx枚举长度的增加，会与矩形一条边有tot−2tot-2tot−2个交点，复杂情况只会走到格点上；最后是求所有xxx可能长度的方法，该方法设000时刻的集合里只有一个000元素，该方法的本质是完成了从i−i+1i-i+1i−i+1的过渡，就是如果我们在已完备的前iii个数中增加一个数，增加的这下标为i+1i+1i+1的值对集合所做的贡献，很明显是前iii个数所构成的所有值+arri+1+arr_i+1+arri​+1，再进行一步去重操作，得到的就是方案数，并且范围1e61e61e6不会超时的； 这个题思考的时间太长了，是不应该的，发现题目范围的端倪之后，应该想到该方法来解，感觉这个方法以前用过。如果直接思考的话最简单的就是枚举这样的话答案是一共有2n2^n2n方种，接受不了。 code：code：code： /************************************************************************* &gt; File Name: problemA.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2020年12月16日 星期三 15时34分48秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) using namespace std; const int N = 1e3+10,maxn = 1e6+10; ll n;ll arr[N],sum = 0; bool st[maxn];ll b[maxn]; void solve()&#123; scanf(&quot;%lld&quot;,&amp;n); ll ans = 0,now = 1; for(ll i=1;i&lt;=n;++i)&#123; scanf(&quot;%lld&quot;,&amp;arr[i]); sum += arr[i]; &#125; ll tot = 0; b[++tot] = 0; st[0] = true; for(ll i=1;i&lt;=n;++i)&#123; ll k = tot; for(ll j=1;j&lt;=k;++j)&#123; ll p = b[j] + arr[i]; if(st[p] == true)continue; b[++tot] = p; st[p] = true; &#125; &#125; //printf(&quot;%lld &quot;,tot); now = tot-3; ans-=(now*(now+1))/2; now++; //printf(&quot;%lld &quot;,now); //printf(&quot;%lld %lld &quot;,ans,now); ans+=now * (sum-1); ans+=2*sum; printf(&quot;%lld &quot;,ans+1); &#125; int main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"POJ.2689PrimeDistance(二次筛法+思维)xiaodangao","path":"/2020/12/12/POJ.2689-Prime Distance(二次筛法+思维)-xiaodangao/","content":"Language:DefaultPrime Distance Time Limit: 1000MSMemory Limit: 65536KTotal Submissions: 32911Accepted: 8353DescriptionThe branch of mathematics called number theory is about properties of numbers. One of the areas that has captured the interest of number theoreticians for thousands of years is the question of primality. A prime number is a number that is has no proper factors (it is only evenly divisible by 1 and itself). The first prime numbers are 2,3,5,7 but they quickly become less frequent. One of the interesting questions is how dense they are in various ranges. Adjacent primes are two numbers that are both primes, but there are no other prime numbers between the adjacent primes. For example, 2,3 are the only adjacent primes that are also adjacent numbers. Your program is given 2 numbers: L and U (1&lt;=L&lt; U&lt;=2,147,483,647), and you are to find the two adjacent primes C1 and C2 (L&lt;=C1&lt; C2&lt;=U) that are closest (i.e. C2-C1 is the minimum). If there are other pairs that are the same distance apart, use the first pair. You are also to find the two adjacent primes D1 and D2 (L&lt;=D1&lt; D2&lt;=U) where D1 and D2 are as distant from each other as possible (again choosing the first pair if there is a tie).InputEach line of input will contain two positive integers, L and U, with L &lt; U. The difference between L and U will not exceed 1,000,000. OutputFor each L and U, the output will either be the statement that there are no adjacent primes (because there are less than two primes between the two given numbers) or a line giving the two pairs of adjacent primes. Sample Input2 17 14 17 Sample Output2,3 are closest, 7,11 are most distant. There are no adjacent primes. SourceWaterloo local 1998.10.17 思路：二次筛法，首先筛一遍2≤i≤sqrt(231)−12\\leq i \\leq sqrt(2^{31})-12≤i≤sqrt(231)−1内的素数，然后利用数组将素数存起来，然后由于l~r区间很小，我们只需要将我们已知的素数通过埃氏筛法再筛一遍就可以得到了，需要注意的是利用了离散化的操作，即在第二次筛法时，每次用G[i-l]来标记i； 再写一点，这个题还是有些许的考思维，因为拿到题很容易无从下手，我当时想了一个假算法，在思考时没有想到用筛法直接映射标记[l,r][l,r][l,r]区间，以后做题要向多方向思考一下，感觉这个题纯粹是用了埃氏筛法的原理，这在以后的做题中也很有帮助； code： /************************************************************************* &gt; File Name: problemC.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2020年12月11日 星期五 18时43分16秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define int long long #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) using namespace std; const int N = 1e5+10,inf = 0x3f3f3f3f; int n,arr[N],l,r; bool st[N]; int prime[N],tot; void getprime()&#123; rep(i,2,N)&#123; if(!st[i])&#123; prime[++tot] = i; if(i&gt;10000)continue; for(int j=i*i;j&lt;=N;j+=i)&#123; st[j] = true; &#125; &#125; &#125; &#125; bool G[N*10+10]; void solve()&#123; getprime(); while(~scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r))&#123; memset(G,0,sizeof G); rep(i,1,tot)&#123; if(prime[i]&gt;r)break; //printf(&quot;%lld &quot;,i); int f = l/prime[i]; for(int j=f*prime[i];j&lt;=r;j+=prime[i])&#123; //printf(&quot;%lld %lld &quot;,prime[i],j); if(j == prime[i])continue; if(j-l&lt;0)continue; G[j-l] = true; &#125; &#125; if(l == 1)G[0] = true; int now[N],k=0, ansl = -1,ansr = -1,x = -1,y = -1,dis1 = -1,dis2 = inf; rep(i,0,r-l)&#123; if(G[i]==false)&#123; now[++k] = i; &#125; &#125; rep(i,2,k)&#123; if(now[i]-now[i-1]&gt;dis1)ansl = now[i-1]+l,ansr = now[i]+l,dis1 = now[i]-now[i-1]; if(now[i]-now[i-1]&lt;dis2)x = now[i-1]+l,y = now[i]+l,dis2 = now[i]-now[i-1]; &#125; if(dis1 == -1)puts(&quot;There are no adjacent primes.&quot;); else printf(&quot;%lld,%lld are closest, %lld,%lld are most distant. &quot;,x,y,ansl,ansr); &#125; &#125; main()&#123; solve(); &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"CH5105.Cookiesxiaodangao","path":"/2020/12/11/CH5105.Cookies-xiaodangao/","content":"5105 Cookies 0x50「动态规划」例题 描述 圣诞老人共有M个饼干，准备全部分给N个孩子。每个孩子有一个贪婪度，第 i 个孩子的贪婪度为 g[i]。如果有 a[i] 个孩子拿到的饼干数比第 i 个孩子多，那么第 i 个孩子会产生 g[i]*a[i]的怨气。给定N、M和序列g，圣诞老人请你帮他安排一种分配方式，使得每个孩子至少分到一块饼干，并且所有孩子的怨气总和最小。1≤N≤30, N≤M≤5000, 1&lt;=gi&lt;=10^7。 输入格式 第一行两个整数N,M，第二行N个整数g1~gN。 输出格式 第一行一个整数表示答案，第二行N个整数表示每个孩子分到的饼干数。本题有SPJ，若有多种方案，输出任意一种均可。 样例输入 样例输入1 3 20 1 2 3 样例输入2 4 9 2 1 5 8 样例输出 样例输出1 2 2 9 9 样例输出2 7 ​2 1 3 3 来源 ITMO 思路，很容易想明白的一点是:每一个小孩拿到的饼干和他的愤怒值成正相关，(如果非正相关可以通过交换两个人的饼干数来达到优化)。然后进行状态判断，此题状态表示很好想，一开始我想用三维数组来表示，f[i][k][s]分别表示当前第几个小孩，拿到几个饼干，还剩几个饼干，显然三维数组内存超限，这就促使我们将三维变成二维数组,f[i][j]表示当前第i个小孩拿到总共j块饼干的最小值,另外注意到一点就是无法确定之前i-1个小孩分别拿了几块饼干;这就使得我们需要进行状态转换,我们将集合划分成第i个小孩拿到是否为1块饼干,进行分类讨论; 第i个小孩拿到1块饼干,那么这时就将问题转化为前面有多少人和他一样？这样做的好处是正好我们会知道前面k个人拿到了总共k块饼干,从而确定状态是f[i-k][j-k]+(sum[i]-sum[i-k])*(i-k); 第i个小孩拿到多于1块饼干,第i个小孩的饼干数都多于1了,我们序列是单调递减的,一个基本要求就是所拿到的饼干数是递减的,所以可以将他转换成第i个小孩拿到1块饼干的状态,即这个状态的值和f[i][j-i]取min;注意这里是指的是f[i][j]与f[i][j-i]在取值上是相同的,然后对于每一项,f[i][j]均比f[i][j-1]多了个1; 关于每一个小孩状态的转换来看,我们可以从后向前来递推的得到具体方案,对于每一项进行判断他是否由f[i][j-i]递推过来,若是,那么整个都＋1;否则进行判断他与那个f[i-k][j-k]相同; code: /************************************************************************* &gt; File Name: Acwing.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2020年12月11日 星期五 10时27分11秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) using namespace std; const int N = 5e3+10,inf = 0x3f3f3f3f; int n,m,f[38][N],now[39][N]; bool cmp(int a,int b)&#123; return a&gt;b; &#125; pair&lt;int,int&gt;g[49]; int sum[49],ans[40]; void solve()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;g[i].first),g[i].second = i; sort(g+1,g+1+n); reverse(g+1,g+1+n); rep(i,1,n)sum[i] = sum[i-1] + g[i].first; memset(f,inf,sizeof f); f[0][0] = 0; rep(i,1,n)&#123; rep(j,1,m)&#123; if(j&gt;=i)f[i][j] = min(f[i][j],f[i][j-i]); rep(k,1,min(i,j))&#123; f[i][j] = min(f[i-k][j-k]+(i-k)*(sum[i]-sum[i-k]),f[i][j]); &#125; &#125; &#125; printf(&quot;%d &quot;,f[n][m]); //求具体方案; int i=n,j=m,h=0; while(i&amp;&amp;j)&#123; if(j&gt;=i&amp;&amp;f[i][j] == f[i][j-i])j-=i,h++; else &#123; rep(k,1,min(i,j))&#123; if(f[i][j] == f[i-k][j-k]+(sum[i]-sum[i-k])*(i-k))&#123; for(int u=i;u&gt;i-k;--u)ans[g[u].second] = 1+h; i-=k;j-=k; break; &#125; &#125; &#125; &#125; rep(s,1,n)printf(&quot;%d &quot;,ans[s]); puts(&quot;&quot;); &#125; int main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"POJ.1236NetworkofSchools(Tarjan缩点+思维)xiaodangao","path":"/2020/12/08/POJ.1236-Network of Schools(Tarjan缩点+思维)-xiaodangao/","content":"Language:DefaultNetwork of Schools Time Limit: 1000MSMemory Limit: 10000KTotal Submissions: 30208Accepted: 11857DescriptionA number of schools are connected to a computer network. Agreements have been developed among those schools: each school maintains a list of schools to which it distributes software (the “receiving schools”). Note that if B is in the distribution list of school A, then A does not necessarily appear in the list of school B You are to write a program that computes the minimal number of schools that must receive a copy of the new software in order for the software to reach all schools in the network according to the agreement (Subtask A). As a further task, we want to ensure that by sending the copy of new software to an arbitrary school, this software will reach all schools in the network. To achieve this goal we may have to extend the lists of receivers by new members. Compute the minimal number of extensions that have to be made so that whatever school we send the new software to, it will reach all other schools (Subtask B). One extension means introducing one new member into the list of receivers of one school. InputThe first line contains an integer N: the number of schools in the network (2 &lt;= N &lt;= 100). The schools are identified by the first N positive integers. Each of the next N lines describes a list of receivers. The line i+1 contains the identifiers of the receivers of school i. Each list ends with a 0. An empty list contains a 0 alone in the line.OutputYour program should write two lines to the standard output. The first line should contain one positive integer: the solution of subtask A. The second line should contain the solution of subtask B. Sample Input5 2 4 3 0 4 5 0 0 0 1 0 Sample Output1 2 SourceIOI 1996 题意：略； 思路：tarjan算法缩点，重点在求解，在tarjan算法将图改为DAG后，注意我们把入度为0的点称为起点，相应的我们把出度为0的点称为终点。第一问询问至少需要几个学校，答案是起点的数量，因为由一个起点能遍历到某些点，但永远不可能遍历到另外一个起点，所以起点的数量就是第一问的答案； 第二问询问至少需要添几条边，将有向图变成强连通图，不妨还是站在起点终点的角度去考虑，我们要变成强连通图，必须保证消灭所有的起点和终点，因为一个点若是起点，那么除自身外任何一个点均到达不了他，一个点若是终点，那么他到达不了任何点，所以应在图中终点连起点，答案就是max(起点数量，终点数量)，需要注意的是存在一种状态，即图本身便是强连通图，即它本身既是起点又是终点，显然情况ans为0； 代码如下： #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #define pb push_back using namespace std; const int N = 1e4+10,M=2e5+10; int n,var[M],head[N],nxt[N],tot,t,cnt,id[N],all[N],dfn[N],low[N];bool st[N]; void add(int x,int y)&#123; var[++tot] = y,nxt[tot] = head[x],head[x] = tot; &#125; vector&lt;int&gt;s[N]; stack&lt;int&gt;G; void tarjan(int x)&#123; low[x] = dfn[x] = ++t; st[x] = true;G.push(x); for(int i=head[x];i;i=nxt[i])&#123; int y = var[i]; if(!dfn[y])&#123; tarjan(y); low[x] = min(low[x],low[y]); &#125; else if(st[y] == true)low[x] = min(low[x],dfn[y]); &#125; if(dfn[x] == low[x])&#123; int k;++cnt; do&#123; k = G.top(); st[k] = false; G.pop(); id[k] = cnt;all[cnt]++; &#125;while(k!=x); &#125; &#125; int in[N],out[N];bool vis[N];int x; void solve()&#123; scanf(&quot;%d&quot;,&amp;n); //tot = 1; for(int i=1;i&lt;=n;++i)while(true)&#123; int v; scanf(&quot;%d&quot;,&amp;v); if(v == 0)break; //if(v == i)continue; add(i,v); &#125; for(int i=1;i&lt;=n;++i)if(!dfn[i])tarjan(i); for(int i=1;i&lt;=n;++i)&#123; for(int y=head[i];y;y=nxt[y])&#123; int p = var[y]; if(id[p]!=id[i])&#123; in[id[p]]++;out[id[i]]++; //s[id[i]].pb(id[p]); &#125; &#125; &#125; int ans2 = 0,ans1 = 0; for(int i=1;i&lt;=cnt;++i)&#123; if(in[i] == 0)&#123; ans1++; &#125; if(out[i] == 0)ans2++; &#125; if(cnt == 1)ans2 = 0; else ans2 = max(ans1,ans2); printf(&quot;%d %d &quot;,ans1,ans2); &#125; int main()&#123; solve(); return 0; &#125; 写在最后，感觉这个将图补成强连通图的问题可以当做一个结论，结论就是max(入度为0的点，出度为0的点)，有些许的偏思维；","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"POJ.3666MakingtheGrade(DP,构造)xiaodangao","path":"/2020/12/07/POJ.3666 Making the Grade(DP,构造 )-xiaodangao/","content":"Language:DefaultMaking the Grade Time Limit: 1000MSMemory Limit: 65536KTotal Submissions: 14460Accepted: 6551DescriptionA straight dirt road connects two fields on FJ's farm, but it changes elevation more than FJ would like. His cows do not mind climbing up or down a single slope, but they are not fond of an alternating succession of hills and valleys. FJ would like to add and remove dirt from the road so that it becomes one monotonic slope (either sloping up or down).You are given N integers A1, ... , AN (1 ≤ N ≤ 2,000) describing the elevation (0 ≤ Ai ≤ 1,000,000,000) at each of N equally-spaced positions along the road, starting at the first field and ending at the other. FJ would like to adjust these elevations to a new sequence B1, . ... , BN that is either nonincreasing or nondecreasing. Since it costs the same amount of money to add or remove dirt at any position along the road, the total cost of modifying the road is|A1 - B1| + |A2 - B2| + ... + |AN - BN |Please compute the minimum cost of grading his road so it becomes a continuous slope. FJ happily informs you that signed 32-bit integers can certainly be used to compute the answer.Input* Line 1: A single integer: N* Lines 2..N+1: Line i+1 contains a single integer elevation: Ai Output* Line 1: A single integer that is the minimum cost for FJ to grade his dirt road so it becomes nonincreasing or nondecreasing in elevation.Sample Input7 1 3 2 4 5 3 9 Sample Output3 SourceUSACO 2008 February Gold 本题思路首先证明一定存在最优解，使得最优解中所有数字都在原数列中出现过，我的想法是这样的，在原序列中找b序列，我们先找不下降序列，那么在arr[i]与arr[i+1]中的b序列，斜率一定是大于等于0的，即使后面arr[i+2]小于这两个数，那b[i+2]与b[i+1]构成的直线最少也是斜率为0的，斜率为零就代表一定b[i+2]=b[i+1]=某一个arr值；那要是arr[i+2]大于arr[i+1]，那在当前状态最优解就是令b[i+2]=arr[i+2]；如果它小于arr[i+1]不过它大于arr[i]，那就令b[i+1]=b[i+2]=arr[i+2];因为这样保证了差值，又保证了b的值最小； 思路：规定状态f[i][j]是第i个序列的值是第j大序列的值；这样f[i][j]=min(f[i-1][1]…f[i-1][j])(最后一个不同点是序列i-1的取值，注意大于i-1不可能大于j)；朴素做法三重循环维护最小值： #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; const int N = 2e3+10,inf = 0x3f3f3f3f; int n,arr[N],brr[N],f[N][N]; int dp()&#123; for(int i=1;i&lt;=n;i++)&#123; //int p = minv;//f[i][j] = min(f[i-1][1-j-1]) for(int j=1;j&lt;=n;++j)&#123; int minv = inf; for(int k=1;k&lt;=j;++k)&#123; minv = min(f[i-1][k],minv); &#125; f[i][j] = minv + abs(arr[i]-brr[j]); &#125; &#125; int ans = inf; for(int i=1;i&lt;=n;++i)&#123; ans = min(ans,f[n][i]); &#125; return ans; &#125; void solve()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i)cin&gt;&gt;arr[i],brr[i] = arr[i]; sort(brr+1,brr+1+n); int ans = dp(); reverse(arr+1,arr+1+n); ans = min(ans,dp()); cout&lt;&lt;ans&lt;&lt;endl; &#125; int main()&#123; solve(); return 0; &#125; 然后我们发现，第三重循环中不就是寻找min(f[i-1,1…j]),第二重循环刚好是从1…j，恰好可以O(1)维护这样一个最小值： #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; const int N = 2e3+10,inf = 0x3f3f3f3f; int n,arr[N],brr[N],f[N][N]; int dp()&#123; for(int i=1;i&lt;=n;i++)&#123; int p = inf; for(int j=1;j&lt;=n;++j)&#123; p = min(f[i-1][j],p); f[i][j] = p + abs(arr[i]-brr[j]); &#125; &#125; int ans = inf; for(int i=1;i&lt;=n;++i)&#123; ans = min(ans,f[n][i]); &#125; return ans; &#125; void solve()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i)cin&gt;&gt;arr[i],brr[i] = arr[i]; sort(brr+1,brr+1+n); int ans = dp(); reverse(arr+1,arr+1+n); ans = min(ans,dp()); cout&lt;&lt;ans&lt;&lt;endl; &#125; int main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"AcWing.274移动服务(DP)xiaodangao","path":"/2020/12/07/AcWing.274移动服务(DP)-xiaodangao/","content":"一个公司有三个移动服务员，最初分别在位置1，2，3处。 如果某个位置（用一个整数表示）有一个请求，那么公司必须指派某名员工赶到那个地方去。 某一时刻只有一个员工能移动，且不允许在同样的位置出现两个员工。 从 p 到 q 移动一个员工，需要花费 c(p,q)。 这个函数不一定对称，但保证 c(p,p)=0。 给出N个请求，请求发生的位置分别为 p1p1p_1~pNpNp_N。 公司必须按顺序依次满足所有请求，且过程中不能去其他额外的位置，目标是最小化公司花费，请你帮忙计算这个最小花费。 输入格式 第1行有两个整数L,N，其中L是位置数量，N是请求数量，每个位置从1到L编号。 第2至L+1行每行包含L个非负整数，第i+1行的第j个数表示c(i,j) ，并且它小于2000。 最后一行包含N个整数，是请求列表。 一开始三个服务员分别在位置1，2，3。 输出格式 输出一个整数M，表示最小花费。 数据范围 3≤L≤2003≤L≤2003 \\le L \\le 200, 1≤N≤10001≤N≤10001 \\le N \\le 1000 输入样例： 5 9 0 1 1 1 1 1 0 2 3 2 1 1 0 4 1 2 1 5 0 1 4 2 3 4 0 4 2 4 1 5 4 3 2 1 输出样例： 5 典型线性DP问题，对于该问题我一直在想如何从维护的当前状态去找历史状态。看了题解之后发现，当一个问题对于它所依赖的状态不好求解时，不妨换个思路，即由当前状态去维护由它能到达的所有状态；这个思路就好像LIS中由i-1推出了i，是根据历史状态维护当前状态，而这个是由i推出i+1，即是根据当前状态去维护下一个状态，这种思路需要保证在计算下一状态时你的当前状态已经是最优的(无后效性) 思路：首先我们发现，必须一定要知道这三个服务员的具体位置，才能够求出相应的解，因为由一个位置移动到另一个位置都会有不同的权值，二维空间不足以维护这么多信息，所以我们规定f[i][x][y]是当前在第i个位置，且另外两个位置分别为x，y时的最小解，而由它能推出(更新)的状态有:f[i+1][x][y],f[i+1][arr[i]][y],f[i+1][x][arr[i]],当然你也可以令当前状态维护后两维相调换的结果,那样做的结果就是保证无顺序性，更新状态也只需要更新到f[i][x][x-1] 代码如下： /************************************************************************* &gt; File Name: acwing.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2020年12月06日 星期日 21时32分50秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair using namespace std; const int N = 1e3+10,L = 2e2+10,inf = 0x3f3f3f3f; int l,n,arr[N],c[L][L],f[N][L][L]; void solve()&#123; scanf(&quot;%d%d&quot;,&amp;l,&amp;n); for(int i=1;i&lt;=l;++i)&#123; for(int j=1;j&lt;=l;++j)&#123; scanf(&quot;%d&quot;,&amp;c[i][j]); &#125; &#125; for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;arr[i]); memset(f,inf,sizeof f); arr[0] = 3; f[0][1][2] = f[0][2][1] = 0; for(int i=0;i&lt;n;++i)&#123; for(int x=1;x&lt;=l;++x)&#123; for(int y=1;y&lt;x;++y)&#123; int p = f[i][x][y]; if(x==y||arr[i]==x||arr[i]==y)continue; f[i+1][x][y] = min(f[i+1][x][y],p+c[arr[i]][arr[i+1]]); f[i+1][y][x] = min(f[i+1][y][x],p+c[arr[i]][arr[i+1]]); f[i+1][y][arr[i]] = min(f[i+1][y][arr[i]],p+c[x][arr[i+1]]); f[i+1][arr[i]][y] = min(f[i+1][arr[i]][y],p+c[x][arr[i+1]]); f[i+1][x][arr[i]] = min(f[i+1][x][arr[i]],p+c[y][arr[i+1]]); f[i+1][arr[i]][x] = min(f[i+1][arr[i]][x],p+c[y][arr[i+1]]); &#125; &#125; &#125; int ans = inf; for(int i=1;i&lt;=l;++i)&#123; for(int j=1;j&lt;=l;++j)&#123; int z = arr[n]; if(z == i||z == j||i==j)continue; ans = min(ans,f[n][i][j]); &#125; &#125; printf(&quot;%d &quot;,ans); &#125; int main()&#123; solve(); return 0; &#125; 写在最后，DP问题确定阶段时，如果阶段不能很容易的由已知量导出，进行附加信息操作。DP问题当所依赖状态不好思考时，不妨考虑维护被依赖状态。","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"凑硬币(DFS+剪枝)xiaodangao","path":"/2020/11/26/凑硬币(DFS+剪枝)-xiaodangao/","content":"韩梅梅喜欢满宇宙到处逛街。现在她逛到了一家火星店里，发现这家店有个特别的规矩：你可以用任何星球的硬币付钱，但是绝不找零，当然也不能欠债。韩梅梅手边有 10410^410​4​​ 枚来自各个星球的硬币，需要请你帮她盘算一下，是否可能精确凑出要付的款额。 输入格式： 输入第一行给出两个正整数：NNN（≤104\\le 10^4≤10​4​​）是硬币的总个数，MMM（≤102\\le 10^2≤10​2​​）是韩梅梅要付的款额。第二行给出 NNN 枚硬币的正整数面值。数字间以空格分隔。 输出格式： 在一行中输出硬币的面值 V1≤V2≤⋯≤VkV_1 \\le V_2 \\le \\cdots \\le V_kV​1​​≤V​2​​≤⋯≤V​k​​，满足条件 V1+V2+...+Vk=MV_1 + V_2 + ... + V_k = MV​1​​+V​2​​+...+V​k​​=M。数字间以 1 个空格分隔，行首尾不得有多余空格。若解不唯一，则输出最小序列。若无解，则输出 No Solution。 注：我们说序列{ A[1],A[2],⋯A[1], A[2], \\cdotsA[1],A[2],⋯ }比{ B[1],B[2],⋯B[1], B[2], \\cdotsB[1],B[2],⋯ }“小”，是指存在 k≥1k \\ge 1k≥1 使得 A[i]=B[i]A[i]=B[i]A[i]=B[i] 对所有 i&lt;ki &lt; ki&lt;k 成立，并且 A[k]&lt;B[k]A[k] &lt; B[k]A[k]&lt;B[k]。 输入样例 1： 8 9 5 9 8 7 2 3 4 1 输出样例 1： 1 3 5 输入样例 2： 4 8 7 2 4 3 输出样例 2： No Solution 思路：这题果断想到利用sort排序(题目要求若有若干个，求字典序最小的)进行dfs，当当前sum+剩余所有可加和小于m时，果断返回false，当当前sum+当前最小可能取值&gt;m时果断返回false，经典可行性剪枝； 代码如下： /************************************************************************* &gt; File Name: problem1.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2020年11月26日 星期四 19时11分46秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair using namespace std; const int N = 1e4+10; int n,m,arr[N],sum[N];bool st[N];int ans[N],cnt; bool dfs(int now,int nowsum,int deep)&#123; nowsum += arr[now]; ans[deep] = arr[now]; if(nowsum == m)&#123; cnt = deep ;return true; &#125; if(nowsum + sum[n] - sum[now]&lt;m||m - nowsum &lt;arr[now+1])return false; for(int i=now+1;i&lt;=n;++i)&#123; if(dfs(i,nowsum,deep+1)==true)return true; &#125; return false; &#125; void solve()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;arr[i]),sum[i] = sum[i-1] + arr[i]; sort(arr+1,arr+1+n);bool flag = false; for(int i=1;i&lt;=n;++i)&#123; if(dfs(i,0,1))&#123;flag = true; for(int j=1;j&lt;=cnt;++j)printf(&quot;%d%c&quot;,ans[j],j==cnt?&#x27; &#x27;:&#x27; &#x27;);break; &#125; &#125; if(flag == false)puts(&quot;No Solution&quot;); &#125; int main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"特殊堆栈(线段树题解)xiaodangao","path":"/2020/11/26/特殊堆栈(线段树题解)-xiaodangao/","content":"堆栈是一种经典的后进先出的线性结构，相关的操作主要有“入栈”（在堆栈顶插入一个元素）和“出栈”（将栈顶元素返回并从堆栈中删除）。本题要求你实现另一个附加的操作：“取中值”——即返回所有堆栈中元素键值的中值。给定 N 个元素，如果 N 是偶数，则中值定义为第 N/2 小元；若是奇数，则为第 (N+1)/2 小元。 输入格式： 输入的第一行是正整数 N（≤105\\le 10^5≤10​5​​）。随后 N 行，每行给出一句指令，为以下 3 种之一： Push key Pop PeekMedian 其中 key 是不超过 10510^510​5​​ 的正整数；Push 表示“入栈”；Pop 表示“出栈”；PeekMedian 表示“取中值”。 输出格式： 对每个 Push 操作，将 key 插入堆栈，无需输出；对每个 Pop 或 PeekMedian 操作，在一行中输出相应的返回值。若操作非法，则对应输出 Invalid。 输入样例： 17 Pop PeekMedian Push 3 PeekMedian Push 2 PeekMedian Push 1 PeekMedian Pop Pop Push 5 Push 4 PeekMedian Pop Pop Pop Pop 输出样例： Invalid Invalid 3 2 2 1 2 4 4 5 3 Invalid 作者陈越单位浙江大学代码长度限制16 KB时间限制400 ms内存限制64 MB 如题所示： 正解：线段树or树状数组； 刚开始想这题想不明白该怎么使用数据结构来解决，然后看了一个大佬树状数组的题解，观察到本题是一个类似于桶排序的方法来解决，由于线段树能维护具有可加性的数据，因为此题范围[1,1e5]那么建树就利用的是每个整数值在序列中出现的次数，二分查找[1,mid]区间出现次数，即可求解； 代码如下： /************************************************************************* &gt; File Name: pta.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2020年11月26日 星期四 15时19分09秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair using namespace std; const int N = 1e6+10,inf = 1e5; int sum[N]; int n,tot,now[N/10];char op[99]; void add(int s,int t,int k,int y,int p)&#123; int mid = (s+t)&gt;&gt;1; if(s==k&amp;&amp;t==k)&#123; sum[p] += y; return; &#125; if(mid&gt;=k)&#123; add(s,mid,k,y,p&lt;&lt;1); &#125; else add(mid+1,t,k,y,p&lt;&lt;1|1); sum[p] = sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1]; return; &#125; int found(int l,int r,int s,int t,int p)&#123; if(l&lt;=s&amp;&amp;t&lt;=r)&#123; return sum[p]; &#125; int ans = 0,mid = (s+t)&gt;&gt;1; if(l&lt;=mid)ans += found(l,r,s,mid,p&lt;&lt;1); if(r&gt;mid)ans += found(l,r,mid+1,t,p&lt;&lt;1|1); return ans ; &#125;int mx = -1; int getans(int x)&#123; int l = 1,r = mx ; int sum = 0; while(l&lt;r)&#123; int mid = (l+r)&gt;&gt;1; sum = found(1,mid,1,inf,1); if(sum&gt;=x) r = mid; else l = mid + 1; &#125; return l; &#125; void solve()&#123; scanf(&quot;%d&quot;,&amp;n); while(n--)&#123; scanf(&quot;%s&quot;,op); if(op[0] == &#x27;P&#x27;&amp;&amp;op[1] == &#x27;o&#x27;)&#123; if(!tot)puts(&quot;Invalid&quot;); else &#123; add(1,inf,now[tot--],-1,1); printf(&quot;%d &quot;,now[tot+1]); &#125; &#125; else if(op[1]==&#x27;u&#x27;)&#123; scanf(&quot;%d&quot;,&amp;now[++tot]); mx = max(mx,now[tot]); add(1,inf,now[tot],1,1); &#125; else &#123; if(!tot)&#123; puts(&quot;Invalid&quot;);continue; &#125; int t = (tot+1)&gt;&gt;1; printf(&quot;%d &quot;,getans(t)); &#125; &#125; return; &#125; int main()&#123; solve(); return 0; &#125; 这个建树是我没想到的，当初的想法想到了或许建树时建1e5个节点，最初设为0；而类似桶排序的思路则是网上树状数组题解提供给我的。这个题感觉是二分答案？二分答案类的题目现在有点不敢想，因为二分答案大多数范围都很大，但其实仔细一想，就多了一个log复杂度，当正向想不出答案时，不妨利用逆向思维，在答案这个集合中进行考虑；","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"ProblemJ.primegame(质因数分解)xiaodangao","path":"/2020/11/24/ProblemJ.prime game(质因数分解)-xiaodangao/","content":"题目链接：https://codeforces.com/gym/101981 题意：给你n个数，让你求[1,n]所有区间的不同质因数个数； 解法：利用试除法分解合数，再分解过程中能求出区间[1,n]中一共有多少个不同素因数，我们假设从[1,n]的所有区间都存在全部不同素因数，等差数列求出区间数，再减去每一个质因数绝对不存在的每个区间； 代码如下： /************************************************************************* &gt; File Name: problemA.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2020年11月22日 星期日 13时01分44秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair using namespace std; ll n,k; const ll N = 1e6+10; bool st[N];ll prime[N],tot,arr[N]; void iniv()&#123; ll m = sqrt(N+0.5);st[1] = 1; for(ll i=2;i&lt;=1000000;++i)&#123; if(!st[i])&#123; prime[++tot] = i; if(i&gt;m)continue; for(ll j=i*i;j&lt;=1000000;j+=i)st[j] = 1; &#125; &#125; &#125; bool vis[N]; ll fac(ll l,ll r)&#123; ll ans = 0; memset(vis,0,sizeof vis); for(ll i=l;i&lt;=r;++i)&#123; ll x = arr[i],now = 1; while(x!=1)&#123; if(x%prime[now]==0)&#123; if(vis[prime[now]]==false)&#123; vis[prime[now]] = true;ans++; &#125; x/=prime[now]; &#125; else now++; &#125; &#125; return ans; &#125; ll G[N]; ll pop[N]; void solve()&#123; scanf(&quot;%lld&quot;,&amp;n); ll cnt = 0,ans = 0; for(ll i=1;i&lt;=n;++i)&#123; scanf(&quot;%lld&quot;,&amp;arr[i]); ll x = arr[i],now = 1; while(x&gt;=prime[now]*prime[now])&#123; if(x%prime[now]==0)&#123; if(G[prime[now]]==0)&#123; pop[++cnt] = prime[now]; &#125; ll d = i - G[prime[now]] - 1; ans -= (d*(d+1))/2; G[prime[now]] = i; while(x%prime[now]==0)x/=prime[now]; &#125; now++; &#125; if(x!=1)&#123; if(G[x]==0)pop[++cnt] = x; ll d = i - G[x] - 1; ans -= (d*(d+1))/2; G[x] = i; &#125; &#125; ll t = (ll)((n*(n+1))/2); ans += cnt*t; //printf(&quot;%lld %lld %lld &quot;,cnt,t,ans); for(ll i=1;i&lt;=cnt;++i)&#123; ll d = n-G[pop[i]]; ans -= (d*(d+1))/2; &#125; printf(&quot;%lld &quot;,ans); &#125; int main()&#123; iniv(); solve(); return 0; &#125; 我们队的合数分解模板存在些问题，看来要给出来了(欧拉筛) const int MAXN = 10000; int prime[MAXN+1]; void getPrime()&#123; memset(prime,0,sizeof prime); for(int i=2;i&lt;=MAXN;++i)&#123; if(!prime[i])prime[++prime[0]] = i; for(int j=1;j&lt;=prime[0]&amp;&amp;prime[j]&lt;=MAXN/i;++j)&#123; prime[prime[j]*i]=1; if(i%prime[j]==0)break; &#125; &#125; &#125; ll factor[100][2]; int fatCnt; int getFactors(ll x)&#123; fatCnt = 0; ll tmp = x; for(int i=1;prime[i]&lt;=tmp/prime[i];++i)&#123; factor[fatCnt][1] = 0; if(tmp%prime[i]==0)&#123; factor[fatCnt][0] = prime[i]; while(tmp%prime[i]==0)&#123; factor[fatCnt][1]++; tmp/=prime[i]; &#125; fatCnt++; &#125; &#125; if(tmp!=1)&#123; factor[fatCnt][0] = tmp; factor[fatCnt][1] = 1; &#125; return fatCnt; &#125; 埃氏筛法见题解；需要注意的是，我们进行质因数分解，只需要分解到x&gt;=prime[now]×prime[now]；最后如果x！=1那么x必是一个大于sqrt（x）的素数，有且只有一个，并且我们在分解的时候也不需要考虑x/prime[now]他是否是一个素数。 总结：这道题从一开始我们首先想到的是前缀和，因为区间个数是n*(n+1)/2个；并且一个区间内的不同质因数个数并不满足可加性，也就是说我们不能将他们放在一起去解题，这样会增大我们的解题难度，于是开始思考题目本身，题目本身给了我们一个很好的暗示，既然要求的是关于质因数的，我们为什么不挨个处理每一个质因数？(因为区间总数我们处理不了)今后要抓住题目所给的条件，不能够犯经验主义的错误；","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"vim一键配置(无插件版）xiaodangao","path":"/2020/11/21/vim一键配置(无插件版）-xiaodangao/","content":"&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot; 显示相关 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot;winpos 5 5 &quot; 设定窗口位置 &quot;set lines=40 columns=155 &quot; 设定窗口大小 &quot;set nu &quot; 显示行号 set go= &quot; 不要图形按钮 &quot;color asmanian2 &quot; 设置背景主题 set guifont=Courier_New:h10:cANSI &quot; 设置字体 &quot;syntax on &quot; 语法高亮 autocmd InsertLeave * se nocul &quot; 用浅色高亮当前行 autocmd InsertEnter * se cul &quot; 用浅色高亮当前行 &quot;set ruler &quot; 显示标尺 set showcmd &quot; 输入的命令显示出来，看的清楚些 &quot;set cmdheight=1 &quot; 命令行（在状态行下）的高度，设置为1 &quot;set whichwrap+=&lt;,&gt;,h,l &quot; 允许backspace和光标键跨越行边界(不建议) &quot;set scrolloff=3 &quot; 光标移动到buffer的顶部和底部时保持3行距离 set novisualbell &quot; 不要闪烁(不明白) set statusline=%F%m%r%h%w\\ [FORMAT=%&#123;&amp;ff&#125;]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %&#123;strftime(\\&quot;%d/%m/%y\\ -\\ %H:%M\\&quot;)&#125; &quot;状态行显示的内容 set laststatus=1 &quot; 启动显示状态行(1),总是显示状态行(2) set foldenable &quot; 允许折叠 set foldmethod=manual &quot; 手动折叠 &quot;set background=dark &quot;背景使用黑色 set nocompatible &quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限 &quot; 显示中文帮助 if version &gt;= 603 set helplang=cn set encoding=utf-8 endif &quot; 设置配色方案 &quot;colorscheme murphy &quot;字体 &quot;if (has(&quot;gui_running&quot;)) &quot; set guifont=Bitstream\\ Vera\\ Sans\\ Mono\\ 10 &quot;endif set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936 set termencoding=utf-8 set encoding=utf-8 set fileencodings=ucs-bom,utf-8,cp936 set fileencoding=utf-8 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot;&quot;&quot;&quot;&quot;新文件标题&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot;新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;:call SetTitle()&quot; &quot;&quot;定义函数SetTitle，自动插入文件头 func SetTitle() &quot;如果文件类型为.sh文件 if &amp;filetype == &#x27;sh&#x27; call setline(1,&quot;\\#########################################################################&quot;) call append(line(&quot;.&quot;), &quot;\\# File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot;\\# Author: Badwoman&quot;) call append(line(&quot;.&quot;)+2, &quot;\\# mail: 1194446133@qq.com&quot;) call append(line(&quot;.&quot;)+3, &quot;\\# Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot;\\#########################################################################&quot;) call append(line(&quot;.&quot;)+5, &quot;\\#!/bin/bash&quot;) call append(line(&quot;.&quot;)+6, &quot;&quot;) else call setline(1, &quot;/*************************************************************************&quot;) call append(line(&quot;.&quot;), &quot; &gt; File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot;\\# Author: Badwoman&quot;) call append(line(&quot;.&quot;)+2, &quot;\\# mail: 1194446133@qq.com&quot;) call append(line(&quot;.&quot;)+3, &quot; &gt; Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot; ************************************************************************/&quot;) call append(line(&quot;.&quot;)+5, &quot;&quot;) endif if &amp;filetype == &#x27;cpp&#x27; call append(line(&quot;.&quot;)+6, &quot;#include&lt;set&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;#include&lt;iostream&gt;&quot;) call append(line(&quot;.&quot;)+8, &quot;#include&lt;cstring&gt;&quot;) call append(line(&quot;.&quot;)+9, &quot;#include&lt;cmath&gt;&quot;) call append(line(&quot;.&quot;)+10, &quot;#include&lt;cstdio&gt;&quot;) call append(line(&quot;.&quot;)+11, &quot;#include&lt;cstdlib&gt;&quot;) call append(line(&quot;.&quot;)+12, &quot;#include&lt;map&gt;&quot;) call append(line(&quot;.&quot;)+13, &quot;#include&lt;algorithm&gt;&quot;) call append(line(&quot;.&quot;)+14, &quot;#include&lt;vector&gt;&quot;) call append(line(&quot;.&quot;)+15, &quot;#include&lt;queue&gt;&quot;) call append(line(&quot;.&quot;)+16, &quot;#include&lt;stack&gt;&quot;) call append(line(&quot;.&quot;)+17, &quot;#define ll long long&quot;) call append(line(&quot;.&quot;)+18, &quot;#define ull unsigned long long&quot;) call append(line(&quot;.&quot;)+19, &quot;#define pb push_back&quot;) call append(line(&quot;.&quot;)+20, &quot;#define mp make_pair&quot;) call append(line(&quot;.&quot;)+21, &quot;#define rep(i,a,b) for(int i=a;i&lt;=b;++i)&quot;) call append(line(&quot;.&quot;)+22, &quot;#define bep(i,a,b) for(int i=a;i&gt;=b;--i)&quot;) call append(line(&quot;.&quot;)+23, &quot;#define lowbit(x) (x&amp;(-x))&quot;) call append(line(&quot;.&quot;)+24, &quot;#define ch() getchar()&quot;) call append(line(&quot;.&quot;)+25, &quot;#define pc(x) putchar(x)&quot;) call append(line(&quot;.&quot;)+26, &quot;using namespace std;&quot;) call append(line(&quot;.&quot;)+27, &quot;&quot;) call append(line(&quot;.&quot;)+28, &quot;template&lt;typename T&gt;void read(T&amp;x)&#123;&quot;) call append(line(&quot;.&quot;)+29, &quot;static char c;static int f;&quot;) call append(line(&quot;.&quot;)+30, &quot;for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f;&quot;) call append(line(&quot;.&quot;)+31, &quot;for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f;&quot;) call append(line(&quot;.&quot;)+32, &quot;&#125;&quot;) call append(line(&quot;.&quot;)+33, &quot;template&lt;typename T&gt;void write(T x)&#123;&quot;) call append(line(&quot;.&quot;)+34, &quot;static char q[65];int cnt=0;&quot;) call append(line(&quot;.&quot;)+35, &quot;if(x&lt;0)pc(&#x27;-&#x27;),x=-x;&quot;) call append(line(&quot;.&quot;)+36, &quot;q[++cnt]=x%10,x/=10;&quot;) call append(line(&quot;.&quot;)+37, &quot;while(x)&quot;) call append(line(&quot;.&quot;)+38, &quot;\tq[++cnt]=x%10,x/=10;&quot;) call append(line(&quot;.&quot;)+39, &quot;while(cnt)pc(q[cnt--]+&#x27;0&#x27;);&quot;) call append(line(&quot;.&quot;)+40, &quot;&#125;&quot;) endif if &amp;filetype == &#x27;c&#x27; call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;&quot;) endif &quot;新建文件后，自动定位到文件末尾 autocmd BufNewFile * normal G endfunc &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot;键盘命令 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; nmap &lt;leader&gt;w :w!&lt;cr&gt; nmap &lt;leader&gt;f :find&lt;cr&gt; &quot; 映射全选+复制 ctrl+a map &lt;C-A&gt; ggVGY map! &lt;C-A&gt; &lt;Esc&gt;ggVGY map &lt;F12&gt; gg=G &quot; 选中状态下 Ctrl+c 复制 vmap &lt;C-c&gt; &quot;+y &quot;去空行 nnoremap &lt;F2&gt; :g/^\\s*$/d&lt;CR&gt; &quot;比较文件 nnoremap &lt;C-F2&gt; :vert diffsplit &quot;新建标签 map &lt;M-F2&gt; :tabnew&lt;CR&gt; &quot;列出当前目录文件 map &lt;F3&gt; :tabnew .&lt;CR&gt; &quot;打开树状文件目录 map &lt;C-F3&gt; \\be &quot;C，C++ 按F5编译运行 map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt; func! CompileRunGcc() exec &quot;w&quot; if &amp;filetype == &#x27;c&#x27; exec &quot;!g++ % -o %&lt;&quot; exec &quot;! ./%&lt;&quot; elseif &amp;filetype == &#x27;cpp&#x27; exec &quot;!g++ % -o %&lt;&quot; exec &quot;! ./%&lt;&quot; elseif &amp;filetype == &#x27;java&#x27; exec &quot;!javac %&quot; exec &quot;!java %&lt;&quot; elseif &amp;filetype == &#x27;sh&#x27; :!./% endif endfunc &quot;C,C++的调试 map &lt;F8&gt; :call Rungdb()&lt;CR&gt; func! Rungdb() exec &quot;w&quot; exec &quot;!g++ % -g -o %&lt;&quot; exec &quot;!gdb ./%&lt;&quot; endfunc &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot;&quot;实用设置 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot; 设置当文件被改动时自动载入 set autoread &quot; quickfix模式 autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt; &quot;代码补全 set completeopt=preview,menu &quot;允许插件 filetype plugin on &quot;共享剪贴板 set clipboard+=unnamed &quot;从不备份 set nobackup &quot;make 运行 :set makeprg=g++\\ -Wall\\ \\ % &quot;自动保存 set autowrite set ruler &quot; 打开状态栏标尺 set cursorline &quot; 突出显示当前行 set magic &quot; 设置魔术 set guioptions-=T &quot; 隐藏工具栏 set guioptions-=m &quot; 隐藏菜单栏 &quot;set statusline=\\ %&lt;%F[%1*%M%*%n%R%H]%=\\ %y\\ %0(%&#123;&amp;fileformat&#125;\\ %&#123;&amp;encoding&#125;\\ %c:%l/%L%)\\ &quot; 设置在状态行显示的信息 set foldcolumn=0 set foldmethod=indent set foldlevel=3 set foldenable &quot; 开始折叠 &quot; 不要使用vi的键盘模式，而是vim自己的 set nocompatible &quot; 语法高亮 set syntax=on &quot; 去掉输入错误的提示声音 set noeb &quot; 在处理未保存或只读文件的时候，弹出确认 set confirm &quot; 自动缩进 set autoindent set cindent &quot; Tab键的宽度 set tabstop=4 &quot; 统一缩进为4 set softtabstop=4 set shiftwidth=4 &quot; 不要用空格代替制表符 set noexpandtab &quot; 在行和段开始处使用制表符 set smarttab &quot; 显示行号 set number &quot; 历史记录数 set history=1000 &quot;禁止生成临时文件 set nobackup set noswapfile &quot;搜索忽略大小写 set ignorecase &quot;搜索逐字符高亮 set hlsearch set incsearch &quot;行内替换 set gdefault &quot;编码设置 set enc=utf-8 set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936 &quot;语言设置 set langmenu=zh_CN.UTF-8 set helplang=cn &quot; 我的状态行显示的内容（包括文件类型和解码） &quot;set statusline=%F%m%r%h%w\\ [FORMAT=%&#123;&amp;ff&#125;]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %&#123;strftime(\\&quot;%d/%m/%y\\ -\\ %H:%M\\&quot;)&#125; &quot;set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%] &quot; 总是显示状态行 set laststatus=2 &quot; 命令行（在状态行下）的高度，默认为1，这里是2 set cmdheight=2 &quot; 侦测文件类型 filetype on &quot; 载入文件类型插件 filetype plugin on &quot; 为特定文件类型载入相关缩进文件 filetype indent on &quot; 保存全局变量 set viminfo+=! &quot; 带有如下符号的单词不要被换行分割 set iskeyword+=_,$,@,%,#,- &quot; 字符间插入的像素行数目 set linespace=0 &quot; 增强模式中的命令行自动完成操作 set wildmenu &quot; 使回格键（backspace）正常处理indent, eol, start等 set backspace=2 &quot; 允许backspace和光标键跨越行边界 set whichwrap+=&lt;,&gt;,h,l &quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位） set mouse=a set selection=exclusive set selectmode=mouse,key &quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过 set report=0 &quot; 在被分割的窗口间显示空白，便于阅读 set fillchars=vert:\\ ,stl:\\ ,stlnc:\\ &quot; 高亮显示匹配的括号 set showmatch &quot; 匹配括号高亮的时间（单位是十分之一秒） set matchtime=1 &quot; 光标移动到buffer的顶部和底部时保持3行距离 set scrolloff=3 &quot; 为C程序提供自动缩进 set smartindent &quot; 高亮显示普通txt文件（需要txt.vim脚本） au BufRead,BufNewFile * setfiletype txt &quot;自动补全 :inoremap ( ()&lt;ESC&gt;i :inoremap ) &lt;c-r&gt;=ClosePair(&#x27;)&#x27;)&lt;CR&gt; :inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O :inoremap &#125; &lt;c-r&gt;=ClosePair(&#x27;&#125;&#x27;)&lt;CR&gt; :inoremap [ []&lt;ESC&gt;i :inoremap ] &lt;c-r&gt;=ClosePair(&#x27;]&#x27;)&lt;CR&gt; :inoremap &quot; &quot;&quot;&lt;ESC&gt;i :inoremap &#x27; &#x27;&#x27;&lt;ESC&gt;i function! ClosePair(char) if getline(&#x27;.&#x27;)[col(&#x27;.&#x27;) - 1] == a:char return &quot;\\&lt;Right&gt;&quot; else return a:char endif endfunction filetype plugin indent on &quot;打开文件类型检测, 加了这句才可以用智能补全 set completeopt=longest,menu &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot; CTags的设定 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; let Tlist_Sort_Type = &quot;name&quot; &quot; 按照名称排序 let Tlist_Use_Right_Window = 1 &quot; 在右侧显示窗口 let Tlist_Compart_Format = 1 &quot; 压缩方式 let Tlist_Exist_OnlyWindow = 1 &quot; 如果只有一个buffer，kill窗口也kill掉buffer let Tlist_File_Fold_Auto_Close = 0 &quot; 不要关闭其他文件的tags let Tlist_Enable_Fold_Column = 0 &quot; 不要显示折叠树 autocmd FileType java set tags+=D:\\tools\\java\\tags &quot;autocmd FileType h,cpp,cc,c set tags+=D:\\tools\\cpp\\tags &quot;let Tlist_Show_One_File=1 &quot;不同时显示多个文件的tag，只显示当前文件的 &quot;设置tags set tags=tags &quot;set autochdir &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot;其他东东 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot;默认打开Taglist let Tlist_Auto_Open=1 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot; Tag list (ctags) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; let Tlist_Ctags_Cmd = &#x27;/usr/bin/ctags&#x27; let Tlist_Show_One_File = 1 &quot;不同时显示多个文件的tag，只显示当前文件的 let Tlist_Exit_OnlyWindow = 1 &quot;如果taglist窗口是最后一个窗口，则退出vim let Tlist_Use_Right_Window = 1 &quot;在右侧窗口中显示taglist窗口 &quot; minibufexpl插件的一般设置 let g:miniBufExplMapWindowNavVim = 1 let g:miniBufExplMapWindowNavArrows = 1 let g:miniBufExplMapCTabSwitchBufs = 1 let g:miniBufExplModSelTarget = 1","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"Acwing.271杨老师的照相馆xiaodangao","path":"/2020/11/20/Acwing.271 杨老师的照相馆-xiaodangao/","content":"有 NNN 个学生合影，站成左端对齐的 kkk 排，每排分别有 N1,N2,…,NkN1,N2,…,NkN_1, N_2, …, N_k 个人。 (N1≥N2≥…≥NkN1≥N2≥…≥NkN_1 \\ge N_2 \\ge … \\ge N_k) 第1排站在最后边，第 kkk 排站在最前边。 学生的身高互不相同，把他们从高到底依次标记为 1,2,…,N1,2,…,N1, 2, …, N。 在合影时要求每一排从左到右身高递减，每一列从后到前身高也递减。 问一共有多少种安排合影位置的方案？ 下面的一排三角矩阵给出了当 N=6,k=3,N1=3,N2=2,N3=1N=6,k=3,N1=3,N2=2,N3=1N=6, k=3,N_1=3,N_2=2,N_3=1 时的全部16种合影方案。注意身高最高的是1，最低的是6。 123 123 124 124 125 125 126 126 134 134 135 135 136 136 145 146 45 46 35 36 34 36 34 35 25 26 24 26 24 25 26 25 6 5 6 5 6 4 5 4 6 5 6 4 5 4 3 3 输入格式 输入包含多组测试数据。 每组数据两行，第一行包含一个整数k表示总排数。 第二行包含k个整数，表示从后向前每排的具体人数。 当输入k=0的数据时，表示输入终止，且该数据无需处理。 输出格式 每组测试数据输出一个答案，表示不同安排的数量。 每个答案占一行。 数据范围 1≤k≤51≤k≤51 \\le k \\le 5,学生总人数不超过30人。 输入样例： 1 30 5 1 1 1 1 1 3 3 2 1 4 5 3 3 1 5 6 5 4 3 2 2 15 15 0 输出样例： 1 1 16 4158 141892608 9694845 思路： 线性DP：先考虑一种做法，将同学按高->低编号n-1 并且按此进行方案的选择//好处：保证当前排的同学是最高的且是已排序的同学中最低的 这样一来我们从需要维护集合的全部信息(无序)转移到了只需利用K元组来维护当前每排的数量且只需要考虑插入一个同学(有序) 启发：以后看到类似具有单调的性质，向集合或数组单调性上考虑，化无序为有序，上一张图方便理解记忆：： 代码如下(有参考大神的代码)： /************************************************************************* &gt; File Name: 271.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2021年03月29日 星期一 16时10分16秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define rep(i,a,b) for(int i=a;i&lt;=b;++i) #define bep(i,a,b) for(int i=a;i&gt;=b;--i) #define lowbit(x) (x&amp;(-x)) #define ch() getchar() #define pc(x) putchar(x) using namespace std; template&lt;typename T&gt;void read(T&amp;x)&#123; static char c;static int f; for(c=ch(),f=1;c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;;c=ch())if(c==&#x27;-&#x27;)f=-f; for(x=0;c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;;c=ch())x=x*10+(c&amp;15);x*=f; &#125; template&lt;typename T&gt;void write(T x)&#123; static char q[65];int cnt=0; if(x&lt;0)pc(&#x27;-&#x27;),x=-x; q[++cnt]=x%10,x/=10; while(x) q[++cnt]=x%10,x/=10; while(cnt)pc(q[cnt--]+&#x27;0&#x27;); &#125; const int N = 31; ll f[N][N][N][N][N]; int n,nx[44]; void solve()&#123; f[0][0][0][0][0] = 1; rep(i,1,30)&#123; rep(j,0,i)&#123; rep(p,0,j)&#123; rep(k,0,p)&#123; rep(t,0,k)&#123; if(i) f[i][j][p][k][t] += f[i-1][j][p][k][t]; if(j) f[i][j][p][k][t] += f[i][j-1][p][k][t]; if(p) f[i][j][p][k][t] += f[i][j][p-1][k][t]; if(k) f[i][j][p][k][t] += f[i][j][p][k-1][t]; if(t) f[i][j][p][k][t] += f[i][j][p][k][t-1]; &#125; &#125; &#125; &#125; &#125; while(true)&#123; read(n); if(!n)break; memset(nx,0,sizeof nx); rep(i,1,n)read(nx[i]); write(f[nx[1]][nx[2]][nx[3]][nx[4]][nx[5]]);pc(&#x27; &#x27;); &#125; &#125; signed main()&#123; solve(); return 0; &#125; 作为dp入门级题目，写在最后，动态规划对状态空间的遍历构成一张有向无环图，遍历顺序就是对该有向无环图的一个拓扑序.节点=状态 边=转移 转移的选取=决策 因此某些时候我们需要将问题变为一张有向无环图进行处理。 动态规划处理问题时通常只需要保留部分信息，观察题目中的变量与不变量，构建状态，应在有些时候抛弃一些无用信息，观察题目中所给的性质。","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"POJ2449.第K短路xiaodangao","path":"/2020/11/19/POJ2449.第K短路-xiaodangao/","content":"Language:DefaultRemmarguts' Date Time Limit: 4000MSMemory Limit: 65536KTotal Submissions: 44482Accepted: 12303Description\"Good man never makes girls wait or breaks an appointment!\" said the mandarin duck father. Softly touching his little ducks' head, he told them a story. \"Prince Remmarguts lives in his kingdom UDF – United Delta of Freedom. One day their neighboring country sent them Princess Uyuw on a diplomatic mission.\" \"Erenow, the princess sent Remmarguts a letter, informing him that she would come to the hall and hold commercial talks with UDF if and only if the prince go and meet her via the K-th shortest path. (in fact, Uyuw does not want to come at all)\" Being interested in the trade development and such a lovely girl, Prince Remmarguts really became enamored. He needs you - the prime minister's help! DETAILS: UDF's capital consists of N stations. The hall is numbered S, while the station numbered T denotes prince' current place. M muddy directed sideways connect some of the stations. Remmarguts' path to welcome the princess might include the same station twice or more than twice, even it is the station with number S or T. Different paths with same length will be considered disparate. InputThe first line contains two integer numbers N and M (1 &lt;= N &lt;= 1000, 0 &lt;= M &lt;= 100000). Stations are numbered from 1 to N. Each of the following M lines contains three integer numbers A, B and T (1 &lt;= A, B &lt;= N, 1 &lt;= T &lt;= 100). It shows that there is a directed sideway from A-th station to B-th station with time T. The last line consists of three integer numbers S, T and K (1 &lt;= S, T &lt;= N, 1 &lt;= K &lt;= 1000).OutputA single line consisting of a single integer number: the length (time required) to welcome Princess Uyuw using the K-th shortest path. If K-th shortest path does not exist, you should output \"-1\" (without quotes) instead.Sample Input2 2 1 2 5 2 1 4 1 2 2 Sample Output14SourcePOJ Monthly,Zeyuan Zhu 题意：给你一张有向图，希望你求出从节点s到t的第K短路 思路：估价函数的选取是根据反向图上根据dijstkra求出由t节点出发的最短路，所以该路径当前到终点的估值就被定义为已走过的路程+该节点到t的最短路径，每次在队列里取出估价最小的状态进行维护，需要注意的是一个节点被取出的次数不能大于K次，如果取出一个节点大于K次，那么从s到t肯定不会走当前的路径，因为总有最优的K条路是经过该节点1~k次到t； Astar算法入门级题目，感觉Astar算法像是优先队列bfs+剪枝 ； 估价函数的设置，这个模板题是根据蓝书的思路自己慢慢敲的，感觉Astar算法的效率与估价函数的设置有很大关系 ； 他是在优先队列BFS的基础上加了些优化 。 ac代码如下 /************************************************************************* &gt; File Name: poj.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2020年11月17日 星期二 20时29分16秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define PII pair&lt;int,int&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair #define x first #define y second using namespace std; const int N = 2e5+10,inf = 0x3f3f3f3f; int n,m,k,l,t,s; vector&lt;int&gt;S[N],H[N],val[N],eva[N];int dist[N];bool st[N]; void dij()&#123; memset(dist,inf,sizeof dist); priority_queue&lt;PII&gt;G; //memset(st,0,sizeof st); dist[t] = 0; G.push(mp(0,t)); while(!G.empty())&#123; int id = G.top().y,pr = -G.top().x;G.pop(); if(st[id]==true)continue; st[id] = true; for(int i=0;i&lt;(int)H[id].size();++i)&#123; int p = H[id][i]; if(val[id][i]+pr&lt;dist[p])&#123; dist[p] = val[id][i]+pr;if(st[p]==false) G.push(mp(-dist[p],p)); &#125; &#125; &#125; return; &#125; int cnt[N]; int bfs()&#123; priority_queue&lt;PII&gt;G; G.push(mp(-dist[s],s)); while(!G.empty())&#123; int id = G.top().y,pr =- G.top().x; G.pop();cnt[id]++; if(cnt[id]&gt;k)continue; if(id==t&amp;&amp;cnt[id]==k)return pr; for(int i=0;i&lt;(int)S[id].size();++i)&#123; int p = S[id][i];if(cnt[p]&gt;=k)continue; G.push(mp(-(pr-dist[id]+dist[p]+eva[id][i]),p)); &#125; &#125; return -1; &#125; void solve()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;++i)&#123;int a,b; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;l); H[b].pb(a);val[b].pb(l);S[a].pb(b);eva[a].pb(l); &#125;scanf(&quot;%d%d%d&quot;,&amp;s,&amp;t,&amp;k); if(m==0)&#123; printf(&quot;-1 &quot;);return; &#125; dij(); printf(&quot;%d &quot;,bfs()); &#125; int main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"Codeforces#681(div.2)D.ExtremeSubtraction(差分序列,构造)xiaodangao","path":"/2020/11/14/Codeforces#681 (div.2)D. Extreme Subtraction(差分序列,构造)-xiaodangao/","content":"D. Extreme Subtraction time limit per test2 seconds memory limit per test256 megabytes You are given an array a of 𝑛 positive integers. You can use the following operation as many times as you like: select any integer 1≤𝑘≤𝑛 and do one of two things: decrement by one 𝑘 of the first elements of the array. decrement by one 𝑘 of the last elements of the array. For example, if 𝑛=5 and 𝑎=[3,2,2,1,4], then you can apply one of the following operations to it (not all possible options are listed below): decrement from the first two elements of the array. After this operation 𝑎=[2,1,2,1,4]; decrement from the last three elements of the array. After this operation 𝑎=[3,2,1,0,3]; decrement from the first five elements of the array. After this operation 𝑎=[2,1,1,0,3]; Determine if it is possible to make all the elements of the array equal to zero by applying a certain number of operations. Input The first line contains one positive integer 𝑡 (1≤𝑡≤30000) — the number of test cases. Then t test cases follow. Each test case begins with a line containing one integer 𝑛 (1≤𝑛≤30000) — the number of elements in the array. The second line of each test case contains n integers 𝑎1…𝑎𝑛 (1≤𝑎𝑖≤106). The sum of n over all test cases does not exceed 30000. Output For each test case, output on a separate line: YES, if it is possible to make all elements of the array equal to zero by applying a certain number of operations. NO, otherwise. The letters in the words YES and NO can be outputed in any case. 题解： 该题属于div.2D题中较为简单的问题，观察可以发现我们只需要处理当a[i]&gt;=a[i-1]且当a[i]&gt;=a[i+1](同时等于不用处理)时的情况，因为如果没有这种情况那么序列一直是单调的，必定有解，该种情况下我们只需要处理一边，即将序列处理为单调的，具体操作还需要维护一个偏移量，我选择处理序列右边的这种情况，该种情况下对于每个a[i]&gt;a[i-1]，序列左端必定全部下降**dlt = a[i]-a[i-1]**个，才能将序列处理为单调递减的；然后判断之后与当前的每个数值是否合法。 题意： 该题意是给你一个序列，你能拥有两种操作，一种是选择k，令a[1]a[k]全体减1；另一种是选择k令a[k]a[n]全体减1； 询问在经过若干次操作后，是否可以使序列全减为0； 方法2： 大佬们用差分序列做，现求出该序列的差分序列，对于每个d[i]若d[i]&lt;0，那么a[1]必定要向下位移|d[i]|个，最后判断a[1]值是否合法； 总结： 该题属于思维题，处理序列，感觉序列问题总与单调性有一定的联系，以后碰到序列问题应及时往这方面去想，提高构造能力 代码如下： /************************************************************************* &gt; File Name: CFD.cpp # Author: Badwoman # mail: 1194446133@qq.com &gt; Created Time: 2020年11月13日 星期五 18时27分00秒 ************************************************************************/ #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define ll long long #define ull unsigned long long #define pb push_back #define mp make_pair using namespace std; const int N = 3e4+10; int arr[N],n,mi[N]; void solve()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;arr[i]); &#125; mi[n] = arr[n];//mi序列能够实时得到该序列下一个最小值 for(int i=n-1;i&gt;=1;--i)&#123; mi[i] = min(arr[i],mi[i+1]); &#125; bool flag = true; int dlt = 0,mina = arr[1];//序列偏移量，利用他能够得到真正序列 for(int i=2;i&lt;=n;++i)&#123; mina = min(mina,arr[i]-dlt); int now = arr[i]-dlt,minb = mi[i]-dlt; if(now&lt;0)&#123; flag = 0;break; &#125; if(arr[i]&gt;=arr[i-1]&amp;&amp;arr[i]&gt;=arr[i+1])&#123; if(arr[i]==arr[i-1]&amp;&amp;arr[i]==arr[i+1])continue; dlt += now - mina;//维护偏移量 //mina-=now - minb; if(minb&lt;now-mina)&#123; flag = false ;break; &#125; mina = now; &#125; &#125; printf(&quot;%s &quot;,flag == true?&quot;YES&quot;:&quot;NO&quot;); &#125; &#125; int main()&#123; solve(); return 0; &#125;","tags":["计算机科学"],"categories":["计算机科学"]},{"title":"关于","path":"/about/index.html","content":"author:xiaodangao Nice to meet you."}]